module core
module core.List.List as ll
module common.utils as commonutils
module common.uniontensor as ut

type TemplateParameters = {input_shape: ll.List<i32>, input_type : rtType, input_dtype : rtType,
                           output_shape : ll.List<i32>, outupt_type : rtType, output_dtype : rtType,
                           scale_factor : f32, align_corners : bool, half_pixel_centers : bool,
                           framework : string, nchw : bool, pack : i32,
                           antialias : bool,
                           size : ll.List<i32>, coord_prefix: string, inputaccess_prefix : string,
                           scales : ut.UnionTensor, zero_points : ut.UnionTensor
                        }
type CodeGenParameters = {
    input_shape : ll.List<i32>,
    input_type : rtType,
    input_dtype : rtType,
    coordlist : ll.List<Tuple>,
    lowcoord_prefix : string,
    highcoord_prefix : string,
    nearcoord_prefix : string,
    coeff_prefix : string,
    inputaccess_prefix : string,
    flatten_idxname : string,
    spatial_iter: string,
    batch_iter : string,
    channel_iter : string,
    input_spatial_shape : ll.List<i32>,
    output_spatial_shape : ll.List<i32>,
    inputterm_prefix : string,
    weighted_prefix : string,
    coeffaccess_prefix : string,
    nchw: bool,
    shiftbit : i32,
    quant : bool,
    nearestcoordlist : ll.List,
    scales : ut.UnionTensor, 
    zero_points : ut.UnionTensor,
}

let rec getNearestInfoList pt_input_coordlist index input_spatial_shape params =
    if (index == (ll.len <| input_spatial_shape)){
        []
    } else{
        let coordtns_eachdim = (ll.item <| index <| pt_input_coordlist)
        let out_height = shapeOf(coordtns_eachdim)[|0|]
        let in_height = ll.item <| index <| input_spatial_shape
        let mut coord = tensor((out_height,), 0i)
        for(i from 0i to out_height){
            if(coordtns_eachdim[(i,)] < 0.0f){
                coord[(i,)] <- 0i
            } else if (coordtns_eachdim[(i,)] > cast<f32>(in_height-1i)){
                coord[(i,)] <- (in_height-1i)
            } else{
                if(coordtns_eachdim[(i,)] - cast<f32>(cast<i32>(coordtns_eachdim[(i,)])) > 0.5f){
                    coord[(i,)] <- (cast<i32>(coordtns_eachdim[(i,)]) + 1i)
                } else{
                    coord[(i,)] <- cast<i32>(coordtns_eachdim[(i,)])
                }
            }
        }

        ll.concat <| [coord] <| (getNearestInfoList <| pt_input_coordlist <| (index+1i) <| input_spatial_shape <| params)
    }


let calculate_interpolate_coord index in_n scale params =
    // index : output coordinate
    // in_n  : input size
    // scale : out_n / in_n
    // get point in original input coordinate
    let _ = if(!params->half_pixel_centers){
        except("Not supported for False half pixel centers for now")
    }
    if (params->align_corners){
        (cast<f32>(in_n) - 1.0f)  / (scale * cast<f32>(in_n) - 1.0f) * cast<f32>(index)  // X_in = (in_n -1) / (scale * in_n - 1) * X_out
    } else{
        (cast<f32>(index) + 0.5f) / scale - 0.5f   // (X_in + 0.5) = (X_out + 0.5) / scale
    }

let rec getBilinearInfoList pt_input_coordlist index input_spatial_shape params quant shiftbit =
    if (index == (ll.len <| input_spatial_shape)){
        []
    } else{
        // point in source coordinate which would match to target point
        let coordtns_eachdim = (ll.item <| index <| pt_input_coordlist)
        let out_height = shapeOf(coordtns_eachdim)[|0|]
        let in_height = ll.item <| index <| input_spatial_shape
        let mut lowcoord = tensor((out_height,), 0i)
        let mut highcoord = tensor((out_height,), 0i)
        let mut highcoeff_float = tensor((out_height,), 0.0f)
        // TODO - replace by builtin min,max
        for(i from 0i to out_height){
            if(coordtns_eachdim[(i,)] < 0.0f){
                lowcoord[(i,)] <- 0i
                highcoord[(i,)] <- 0i
                highcoeff_float[(i,)] <- 0.0f
            } else if (coordtns_eachdim[(i,)] > cast<f32>(in_height-1i)){
                lowcoord[(i,)] <- (in_height-1)
                highcoord[(i,)] <- (in_height-1)
                highcoeff_float[(i,)] <- 1.0f
            } else{
                let highval = if ( (cast<i32>(coordtns_eachdim[(i,)]) + 1i) > (in_height-1i)){
                    cast<i32>(coordtns_eachdim[(i,)])
                } else{
                    cast<i32>(coordtns_eachdim[(i,)]) + 1i
                }
                highcoord[(i,)] <- highval
                lowcoord[(i,)] <- cast<i32>(coordtns_eachdim[(i,)])
                highcoeff_float[(i,)] <- (coordtns_eachdim[(i,)] - cast<f32>(lowcoord[(i,)]))
            }
        }
        let highcoeff = if(quant){
            let mut highcoeff_int32 = tensor((out_height,), 0i32)
            for(i from 0i to out_height){
                highcoeff_int32[(i,)] <- cast<i32>( highcoeff_float[(i,)] * cast<f32>(1i << shiftbit) + 0.5f)   // (2^11 * coeff_float)) for 2D
            }
            ut.TensorI32(highcoeff_int32)
        } else if(params->input_dtype == rtType(f16)){
            ut.TensorF16(cast<f16>(highcoeff_float))
        } else{
            ut.TensorF32(highcoeff_float)
        }

        ll.concat <| [(lowcoord, highcoord, highcoeff)] <| (getBilinearInfoList <| pt_input_coordlist <| (index+1i) <| input_spatial_shape <|  params <| quant <| shiftbit)
    }

let prepareInputPattern params quant =
    let ndims = ll.len <| (params->output_shape)
    let _ = if (ndims < 3i){
        except("interpolate requires at least 3dim tensor")
    }

    let (output_spatial_shape, input_spatial_shape) = 
        if(params->nchw){
            (ll.drop <| 2i <| (params->output_shape), ll.drop <| 2i <| (params->input_shape))
        } else{
            // (params->output_shape[1i:(ndims-1i)], params->input_shape[1i:(ndims-1i)])
            ( ll.reverse <| (ll.drop <| 1i <| (ll.reverse <| (ll.drop <| 1i <| (params->output_shape)))) , ll.reverse <| (ll.drop <| 1i <| (ll.reverse <| (ll.drop <| 1i <| (params->input_shape)))) )
        }
    let outlen_wo_channel = commonutils.factorial <| output_spatial_shape
    let shiftbit = (31 - 8) / (ll.len <| input_spatial_shape)    

    let rec getPtInputCoord index =
        if(index == (ll.len <| output_spatial_shape)){
            []
        } else{
            let lennum = ll.item <| index <| output_spatial_shape
            let mut pt_input_coord = tensor(( lennum,), 0.0f32)
            for(i from 0 to (ll.item <| index <| output_spatial_shape)){
                pt_input_coord[(i,)] <- calculate_interpolate_coord <| i <| (ll.item <| index <| input_spatial_shape) <| (cast<f32>((ll.item <| index <| output_spatial_shape)) / cast<f32>((ll.item <| index <| input_spatial_shape))) <| params
            }

            ll.concat <| [pt_input_coord] <| (getPtInputCoord <| (index + 1i))
        }
    let pt_input_coordlist = getPtInputCoord <| 0i // List of point to which target point matches in source coordinates. Dimension of list is that of spatial shape

    let interpolate_infolist = getBilinearInfoList <| pt_input_coordlist <| 0i <| input_spatial_shape  <| params <| quant <| shiftbit

    let nearest_infolist = getNearestInfoList <| pt_input_coordlist <| 0i <| input_spatial_shape <| params

    (interpolate_infolist, nearest_infolist, input_spatial_shape, output_spatial_shape, shiftbit)

let initCodeGen params =
    let quant = if(params->input_dtype == rtType(f32) || params->input_dtype == rtType(f16)){
        false
    } else if(params->input_dtype == rtType(i8)){
        true
    } else{
        except("Not supported dtype " + toStr(params->input_dtype))
    }   
    let (coordlist, nearestcoordlist, input_spatial_shape , output_spatial_shape, shiftbit) = prepareInputPattern params quant

    let codeGenParameters = CodeGenParameters(params->input_shape, params->input_type, params->input_dtype, coordlist, "low"+params->coord_prefix, "high"+params->coord_prefix, "near"+params->coord_prefix, "coeff"+params->coord_prefix,
                                            params->inputaccess_prefix, "flatten_idx", "spatial_iter", "batch_iter", "channel_iter", input_spatial_shape, output_spatial_shape,  "inputterm_", "weighted_", "accessed_coeff_", params->nchw, shiftbit, quant, nearestcoordlist,
                                            params->scales, params->zero_points)
    
    codeGenParameters

let get_Spatial_index runtimeiter params =
    // should be reverse to access contiguously memory
    let output_spatial_shape = params->output_spatial_shape

    let rec get_Spatial_index_impl num steps =
        if(steps < 0i){
            []
        } else{
            let curidx = !{${num} % ${ll.item <| steps <| output_spatial_shape}}
            let nextnum = !{(${num} - ${curidx}) / ${ll.item <| steps <| output_spatial_shape}}
            ll.concat <| (get_Spatial_index_impl <| nextnum <| (steps-1i)) <| [curidx]
        }
    get_Spatial_index_impl <| runtimeiter <| ((ll.len <| output_spatial_shape) - 1i)


_end_