module core.List.List as ll
module common.uniontensor as ut
module common.params as params

template</attr_params: params.Attributes, optim_params: params.Optimization, layer_params: ll.List<params.Layerargs>,
    input_data: ll.List<ll.List<ut.UnionTensor>>, input_dtypes: ll.List<ll.List<rtType>>, input_shapes: ll.List<ll.List<i32>>, input_scales: ll.List<ll.List<ut.UnionTensor>>, input_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    output_dtypes: ll.List<ll.List<rtType>>, output_shapes: ll.List<ll.List<i32>>, output_scales: ll.List<ll.List<ut.UnionTensor>>, output_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    input_edges: ll.List<ll.List<tuple<i32, i32>>>, output_edges: ll.List<ll.List<tuple<i32, i32>>>, ismainops: ll.List<boolean>,
    input_t: rtType, input_rt_list : ll.List<rtType>,  output_t: rtType, output_rt_list : ll.List<rtType>/>
attr[Extern : attr_params->name, Optimization : { VectorSize : 512 }]
fun batch_to_space(inputs: input_t, mut &outputs: output_t) -> i32 {
    ${  
        let layerindex = (
            let mut index = 0
            for(i from 0 to (ll.len layer_params)){
                match (ll.item i layer_params) with 
                    | params.Batch_to_space x   -> if((ll.item i ismainops)){index <- i} else{_end_}
                    | _                 -> _end_
            }
            index
        )

        let layerparams = 
            match (ll.item layerindex0 layer_params) with 
                | params.Batch_to_space x -> x

        let pack = ll.item 0 (optim_params->pack)
        let unroll = ll.item 0 (optim_params->unroll)
        let input1_dtype = ll.item 0 (ll.item layerindex input_dtypes)
        let input1_shape = ll.item 0 (ll.item layerindex input_shapes)
        let input1_scales = ll.item 0 (ll.item layerindex input_scales)
        let input1_zero_points = ll.item 0 (ll.item layerindex input_zero_points)
        let output_shape = ll.item 0 (ll.item layerindex output_shapes)
        let output_scales = ll.item 0 (ll.item layerindex output_scales)
        let output_zero_points = ll.item 0 (ll.item layerindex output_zero_points)  
        
        let block_shape = layerparams -> block_shape
        let crops = layerparams -> crop
        let input1_dim = ll.len input1_shape

        let block_dim = ll.len block_shape

        let rec shape_size index shape data =
            if(index == (ll.len shape)){
                data
            } else{
                shape_size (index+1) shape (data*(ll.item index shape))
            }
        let input1_size = shape_size 0 input1_shape 1
        let output_size = shape_size 0 output_shape 1
        let block_size = shape_size 0 block_shape 1
        let loofsize = block_size*(ll.item 1 input1_shape)*(ll.item 2 input1_shape)*(ll.item 3 input1_shape)

        let _ = if((pack * unroll > input1_size)){
            except("pack * unroll(" + toStr(pack * unroll) + ") should be larger than size of input1(" + toStr(input1_size) + ")")
        } else{
            _end_
        }
        
        let div_batch div shape = 
            match shape with
            | h;t   -> h/div;t

        let reshape_input_shape = ll.concat (block_shape) (div_batch block_size input1_shape)
        let reshape_input_dim = ll.len reshape_input_shape

        let transpose_params = 
            let rec get_transpose_params index=
                if(index == 0){
                    (block_dim);(get_transpose_params (index+1))
                }else if (index >= (2*(block_dim)+1)){
                    if(index == reshape_input_dim - 1){
                        [index]
                    }else {
                        index;(get_transpose_params (index+1))
                    }
                }else{
                    if(index == reshape_input_dim - 2){
                        [(block_dim+1+index/2);(index/2)]
                    }else {
                        (block_dim+1+index/2);((index/2);get_transpose_params (index+2))
                    }
                }
            get_transpose_params 0
        let transposed_shape = 
            let rec get_transposed_shape index =
                if(index == reshape_input_dim-1){
                    [ll.item (ll.item index transpose_params) reshape_input_shape]
                }else{
                    (ll.item (ll.item index transpose_params) reshape_input_shape);(get_transposed_shape (index+1))
                }
            get_transposed_shape 0
        
        let reshaped_transposed_shape = 
            let rec get_reshaped_transposed_shape index =
                if(index == 0){
                    (ll.item 0 transposed_shape);(get_reshaped_transposed_shape (index+1))
                }else if(index >= (2*(block_dim)+1)){
                    if(index == ((ll.len transposed_shape) - 1)){
                        [ll.item index transposed_shape]
                    }else{
                        (ll.item index transposed_shape);(get_reshaped_transposed_shape (index+1))
                    }
                }else{
                    if(index == ((ll.len transposed_shape) - 2)){
                        [(ll.item index transposed_shape)*(ll.item (index+1) transposed_shape)]
                    }else{
                        (ll.item index transposed_shape)*(ll.item (index+1) transposed_shape);(get_reshaped_transposed_shape (index+2))
                    }
                }
            get_reshaped_transposed_shape 0

        let sum_crops c = 
            ((ll.item 0 c) + (ll.item 1 c))

        let croped_shape = 
            let rec get_croped_shape index =
                if(index == 0){
                    (ll.item 0 reshaped_transposed_shape);(get_croped_shape (index+1))
                }else if(index > block_dim){
                    if(index == ((ll.len reshaped_transposed_shape) - 1)){
                        [ll.item index reshaped_transposed_shape]
                    }else {
                        (ll.item index reshaped_transposed_shape);(get_croped_shape (index+1))
                    }
                }else{
                    if(index == ((ll.len reshaped_transposed_shape) - 1)){
                        [ll.item index reshaped_transposed_shape - (sum_crops (ll.item (index-1) crops))]
                    }else{
                        (ll.item index reshaped_transposed_shape - (sum_crops (ll.item (index-1) crops)));(get_croped_shape (index+1))
                    }
                }
            get_croped_shape 0

        let croped_size = shape_size 0 croped_shape 1
        let croped_str = 
            let rec get_croped_str index =
                if(index == 0){
                    ("0:"+toStr(ll.item 0 reshaped_transposed_shape) + ":1");(get_croped_str (index+1))
                }else if(index > block_dim){
                    if(index == ((ll.len reshaped_transposed_shape) - 1)){
                        ["0:" + toStr(ll.item index reshaped_transposed_shape) + ":1"]
                    }else {
                        ("0:" + toStr(ll.item index reshaped_transposed_shape) + ":1");(get_croped_str (index+1))
                    }
                }else{
                    if(index == ((ll.len reshaped_transposed_shape) - 1)){
                        [(toStr(ll.item 0 (ll.item (index-1) crops))+":"+toStr((ll.item index reshaped_transposed_shape) - (ll.item 1 (ll.item (index-1) crops))) + ":1")]
                    }else{
                        (toStr(ll.item 0 (ll.item (index-1) crops))+":"+toStr((ll.item index reshaped_transposed_shape) - (ll.item 1 (ll.item (index-1) crops))) + ":1");(get_croped_str (index+1))
                    }
                }
            get_croped_str 0

        let transpose_dim = ll.len transpose_params

        let rec find_index data idx list = 
            if(idx == ll.len list){
                except("no data")
            } else if(ll.item idx list == data){
                idx
            } else{
                find_index data (idx+1) list
            }
        
        let index_range = 
            let s2 = transpose_dim-1
            let s1 = 
                if((ll.item s2 transpose_params) == transpose_dim-1){
                    (transpose_dim-2)
                }else{
                    (ll.item s2 transpose_params)
                }

            let rec get_range switch1 switch2 index = 
                if(index == transpose_dim){
                    []
                }else if(index == switch1){
                    (switch2);(get_range switch1 switch2 (index+1))
                }else if(index == switch2){
                    (switch1);(get_range switch1 switch2 (index+1))
                }else{
                    (index);(get_range switch1 switch2 (index+1))
                }
            get_range s1 (s2-1) 0

        let rec index_str index =
            if (index == transpose_dim-1){
                [(!{${"idx"+toStr(index)}})]
            } else{
                (!{${"idx"+toStr(index)}});(index_str (index+1))
            }
        
        let rec output_index_str index =
            if (index == transpose_dim-1){
                [!{${"idx" + toStr(ll.item (index) transpose_params)}}]
            } else {
                ll.concat ([!{${"idx" + toStr(ll.item (index) transpose_params)}}]) (output_index_str (index+1))
            }

        let ind_str = index_str 0
        let out_str = output_index_str 0
        let rec do_transpose idx = 
            if (idx == reshape_input_dim - 1){
                !{
                    for(${"idx"+toStr((ll.item idx index_range))} from 0 to ${ll.item (ll.item idx index_range) reshape_input_shape} step 1){
                        transposed_data[${ll.toRtTuple out_str}] <- reshape_input1[${ll.toRtTuple ind_str}]
                    }
                    _end_
                }
            }else {
                !{
                    for(${"idx"+toStr(ll.item idx index_range)} from 0 to ${ll.item (ll.item idx index_range) reshape_input_shape} step 1){
                        ${do_transpose (idx+1)}
                    }
                    ${
                        if (idx == 0){
                            !{
                                let mut reshaped_transposed_data = reshapeTo(${ll.toRtTuple reshaped_transposed_shape},&transposed_data)
                                let croped_data = reshaped_transposed_data[${ll.toRtTuple croped_str}]
                                outp[(0:${croped_size}:1,)] <- reshapeTo((${croped_size},),croped_data)
                                0
                            }
                        } else{
                            !{_end_}
                        }
                    }
                }
            }
        !{
            let mut batchoutput = &outputs[|0|]
            let batchinput1 = inputs[|0|]
            let reshape_input1 = reshapeTo(${ll.toRtTuple reshape_input_shape},&batchinput1)
            let mut transposed_data = tensor(${ll.toRtTuple transposed_shape},0f32)
            let mut outp = reshapeTo((${output_size},),&batchoutput)

            ${do_transpose 0}
        }
    }
}