type UnionTensor =
    | TensorI8 of tensor<i8, 1>
    | TensorI16 of tensor<i16, 1>
    | TensorI32 of tensor<i32, 1>
    | TensorI64 of tensor<i64, 1>
    | TensorF16 of tensor<f16, 1>
    | TensorF32 of tensor<f32, 1>
    | EMPTY

let typeof uniontensor = 
    match uniontensor with
        | TensorI8 t    -> type(t)
        | TensorI16 t   -> type(t)
        | TensorI32 t   -> type(t)
        | TensorI64 t   -> type(t)
        | TensorF16 t   -> type(t)
        | TensorF32 t   -> type(t)
        | EMPTY         -> except("EMPTY tensor cannot be converted to runtime expression")

let toRtTensor uniontensor =
    let tort t = !{${t}}
    match uniontensor with 
        | TensorI8 t    -> tort t
        | TensorI16 t   -> tort t
        | TensorI32 t   -> tort t
        | TensorI64 t   -> tort t
        | TensorF16 t   -> tort t
        | TensorF32 t   -> tort t
        | EMPTY         -> except("EMPTY tensor cannot be converted to runtime expression")

let toRtTensorWithShape uniontensor shape = 
    let tort t = if(shape[|0|] == -1){!{${t}}} else{!{${reshapeTo(shape, t)}}}
    match uniontensor with 
        | TensorI8 t    -> tort t
        | TensorI16 t   -> tort t
        | TensorI32 t   -> tort t
        | TensorI64 t   -> tort t
        | TensorF16 t   -> tort t
        | TensorF32 t   -> tort t
        | EMPTY         -> except("EMPTY tensor cannot be converted to runtime expression")

let isQuant uniontensor =
    match uniontensor with
        | TensorI8 t -> true
        | _         -> false

let isEmpty uniontensor = 
    match uniontensor with
        | EMPTY     -> true
        | _         -> false

let toCtTensorI8 uniontensor =
    match uniontensor with 
        | TensorI8 t   -> t
        | _             -> except("only TensorI8 can be converted to tensor<i8, 1>")

let toCtTensorI16 uniontensor =
    match uniontensor with 
        | TensorI16 t   -> t
        | _             -> except("only TensorI16 can be converted to tensor<i16, 1>")

let toCtTensorI32 uniontensor =
    match uniontensor with 
        | TensorI32 t   -> t
        | _             -> except("only TensorI32 can be converted to tensor<i32, 1>")

let toCtTensorI64 uniontensor =
    match uniontensor with 
        | TensorI64 t   -> t
        | _             -> except("only TensorI64 can be converted to tensor<i64, 1>")

let toCtTensorF16 uniontensor =
    match uniontensor with 
        | TensorF16 t   -> t
        | _             -> except("only TensorF16 can be converted to tensor<f16, 1>")

let toCtTensorF32 uniontensor =
    match uniontensor with 
        | TensorF32 t   -> t
        | _             -> except("only TensorF32 can be converted to tensor<f32, 1>")

let dtypeStr uniontensor =
    match uniontensor with
        | TensorI8 t    -> "i8"
        | TensorI16 t   -> "i16"
        | TensorI32 t   -> "i32"
        | TensorI64 t   -> "i32"
        | TensorF16 t   -> "f16"
        | TensorF32 t   -> "f32"
        | EMPTY         -> "empty"

let multf32toi32 multf32ut significant_bits =
    match multf32ut with
        | TensorF32 multf32  ->
            let signMask = 0x80000000u32
            let exponentMask = 0x7F800000u32
            let exponentShift = 23u32
            let exponentBias = 127u32
            let fractionMask = 0x007FFFFFu32
            let fractionShift = 7u32
            let fractionOne = 0x00800000u32
            let shiftbuff = 7

            let mut mult = tensor(shapeOf(multf32), 1i32)
            let mut shift = tensor(shapeOf(multf32), 0i32)

            for (i from 0 to shapeOf(multf32)[|0|]){
                let multf32_bits = bitcast<u32>(multf32[(i,)])
                if(significant_bits > 16){
                    mult[(i,)] <- cast<i32>(((multf32_bits & fractionMask) | fractionOne) << fractionShift)
                    shift[(i,)] <- (1) * ((exponentBias + (31 - 32) - (multf32_bits >> exponentShift)))
                } else{
                    mult[(i,)] <- (cast<i32>(((multf32_bits & fractionMask) | fractionOne) << fractionShift) + (1 << (31 - significant_bits))) >> (31 - significant_bits)
                    // mult[(i,)] <- (cast<i32>(((multf32_bits & fractionMask) | fractionOne) << fractionShift)) >> (31 - significant_bits)
                    shift[(i,)] <- (1) * ((exponentBias + significant_bits - 1 - (multf32_bits >> exponentShift)))
                }
            }

            (TensorI32(mult), TensorI32(shift))
        | _                     -> (EMPTY, EMPTY)

let reshapeUnionTensor uniontensor tensor_shape =
    match uniontensor with
        | TensorI8 t    -> TensorI8  <| reshapeTo(tensor_shape,  t)
        | TensorI16 t   -> TensorI16 <| reshapeTo(tensor_shape,  t)
        | TensorI32 t   -> TensorI32 <| reshapeTo(tensor_shape,  t)
        | TensorI64 t   -> TensorI64 <| reshapeTo(tensor_shape,  t)
        | TensorF16 t   -> TensorF16 <| reshapeTo(tensor_shape,  t)
        | TensorF32 t   -> TensorF32 <| reshapeTo(tensor_shape,  t)
        | EMPTY         -> EMPTY


_end_