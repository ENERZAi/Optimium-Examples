module core.List.List as ll
module common.uniontensor as ut
module common.params as params

template</attr_params: params.Attributes, optim_params: params.Optimization, layer_params: ll.List<params.Layerargs>,
    input_data: ll.List<ll.List<ut.UnionTensor>>, input_dtypes: ll.List<ll.List<rtType>>, input_shapes: ll.List<ll.List<i32>>, input_scales: ll.List<ll.List<ut.UnionTensor>>, input_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    output_dtypes: ll.List<ll.List<rtType>>, output_shapes: ll.List<ll.List<i32>>, output_scales: ll.List<ll.List<ut.UnionTensor>>, output_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    input_edges: ll.List<ll.List<tuple<i32, i32>>>, output_edges: ll.List<ll.List<tuple<i32, i32>>>, ismainops: ll.List<boolean>,
    input_t: rtType, input_rt_list : ll.List<rtType>,  output_t: rtType, output_rt_list : ll.List<rtType>/>
attr[Extern : attr_params->name, Optimization : { VectorSize : 512 }]
fun pixelshuffle(inputs: input_t, mut &outputs: output_t) -> i32 {
    ${  
        let layerindex = (
            let mut index = 0
            for(i from 0 to (ll.len layer_params)){
                match (ll.item i layer_params) with 
                    | params.Pixelshuffle x   -> if((ll.item i ismainops)){index <- i} else{_end_}
                    | _                 -> _end_
            }
            index
        )
        let thislayer_params = 
            match (ll.item index layer_params) with
                | params.Pixelshuffle x -> x
        
        let input_dtype = ll.item 0 (ll.item layerindex input_dtypes)
        let input_shape = ll.item 0 (ll.item layerindex input_shapes)
        let input_scales = ll.item 0 (ll.item layerindex input_scales)
        let input_zero_points = ll.item 0 (ll.item layerindex input_zero_points)
        let output_dtype = ll.item 0 (ll.item layerindex output_dtypes)
        let output_shape = ll.item 0 (ll.item layerindex output_shapes)
        let output_scales = ll.item 0 (ll.item layerindex output_scales)
        let output_zero_points = ll.item 0 (ll.item layerindex output_zero_points)
        let pack = ll.item 0 (optim_params->pack)
        let unroll = ll.item 0 (optim_params->unroll)

        let block_size = thislayer_params->block_size
        
        let h = ll.item 1 input_shape
        let w = ll.item 2 input_shape 
        let c = ll.item 3 input_shape 

        let _ = if(c % (block_size * block_size) != 0){
            except("Dimension size must be evenly divisible by (" + toStr(block_size * block_size) + ") but is (" + toStr(c) + ")")
        } else{
            _end_
        }

        let rec shape_size index shape data =
            if(index == ll.len shape){
                data
                
            } else{
                shape_size (index+1) shape (data*(ll.item index shape))
            }
        let input_size = shape_size 0 input_shape 1
        let output_size = shape_size 0 output_shape 1
        let _ = if(pack * unroll > input_size){
            except("pack * unroll(" + toStr(pack * unroll) + ") should be larger than one of the shape of last dimension of input(" + toStr(input_size) + ")")
        } else{
            _end_
        }
        let tiles =
            if(input_size % (pack*unroll) == 0){
                [(0, input_size); (input_size, input_size)]
            } else{
                let end1 = input_size - (input_size % (pack*unroll))
                [(0, end1); (end1, input_size)]
            }
        
        
        let step_size = c/block_size
        let base_size = w*c
        !{
            let mut batchoutput = &outputs[|0|]
            let batchinput = inputs[|0|]
            let flat_input = reshapeTo(${(input_size,)}, batchinput)
            let mut flat_output = reshapeTo((${output_size},),&batchoutput)
                                
            for(idx1 from 0 to ${h}){
                for(idx2 from 0 to ${block_size}){
                    for(idx3 from 0 to ${w}){
                        flat_output[((idx1*${w*block_size}+idx2*${w}+idx3)*${step_size}:(idx1*${w*block_size}+idx2*${w}+idx3)*${step_size}+${step_size}:1i,)] <- flat_input[((idx1*${w*block_size}+idx2+idx3*${block_size})*${step_size}:((idx1*${w*block_size}+idx2+idx3*${block_size})*${step_size}+${step_size}):1i,)]
                        _end_
                    }
                    _end_
                }
                _end_
            }
            0
        }
        
    }

     
}

