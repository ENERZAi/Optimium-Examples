module core.List.List as ll
module common.utils as commonutils

template</attr_params: params.Attributes, optim_params: params.Optimization, layer_params: ll.List<params.Layerargs>,
    input_data: ll.List<ll.List<ut.UnionTensor>>, input_dtypes: ll.List<ll.List<rtType>>, input_shapes: ll.List<ll.List<i32>>, input_scales: ll.List<ll.List<ut.UnionTensor>>, input_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    output_dtypes: ll.List<ll.List<rtType>>, output_shapes: ll.List<ll.List<i32>>, output_scales: ll.List<ll.List<ut.UnionTensor>>, output_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    input_edges: ll.List<ll.List<tuple<i32, i32>>>, output_edges: ll.List<ll.List<tuple<i32, i32>>>, ismainops: ll.List<boolean>,
    input_t: rtType, input_rt_list : ll.List<rtType>,  output_t: rtType, output_rt_list : ll.List<rtType>/>
attr[Extern : attr_params->name, Optimization : { VectorSize : 512 }]
fun reshape(inputs : input_t, mut &outputs: output_t) -> i32{
    ${
        let inplace = optim_params->inplace
        let pack = ll.item 0 (optim_params->pack)
        let unroll = ll.item 0 (optim_params->unroll)
        // if(inplace){
        //     !{
        //         0
        //     }
        // }  else{
            let input_shape = ll.item 0 (ll.item 0 input_shapes)
            let output_shape = ll.item 0 (ll.item 0 output_shapes)
            let inputnum = commonutils.factorial <| input_shape
            let outputnum = commonutils.factorial <| output_shape

            let vecrem = inputnum % (pack * unroll)
            let vecname = "vec"
            
            let rec get_expr start end num index = 
                if(index == (num-1)){
                    !{
                        let ${vecname + toStr(index)} = input_reshaped[  ((${start} + ${index * pack}) : ${end}:1i, ) ]
                        output_reshaped[  ((${start} + ${index * pack}) : ${end}:1i, ) ] <- ${vecname + toStr(index)}
                        0
                    }
                } else{
                    !{
                        let ${vecname + toStr(index)} = input_reshaped[  ((${start} + ${index * pack}) : (${start} + ${(index+1) * pack}):1i, ) ]
                        output_reshaped[  ((${start} + ${index * pack}) : (${start} + ${(index+1) * pack}):1i, ) ] <- ${vecname + toStr(index)}
                        ${
                            get_expr <| start <| end <| num <| (index+1)
                        }
                    }
                }

            !{
                let input_reshaped = reshapeTo((${inputnum},), inputs[|0|])
                let mut output_reshaped = reshapeTo((${outputnum},), &outputs[|0|])
                for(p0 from 0 to ${inputnum - vecrem} step ${pack * unroll}){
                    ${ get_expr <| !{p0} <| !{p0 +${unroll * pack}} <| unroll <| 0}
                }
                ${
                    if (vecrem > 0){
                        if (pack == 1){
                            get_expr <| (inputnum -vecrem) <| inputnum <| vecrem <| 0
                        } else{
                            get_expr <| (inputnum -vecrem) <| inputnum <| ((vecrem-1) / pack + 1) <| 0
                        }
                    } else{
                        !{
                            0
                        }
                    }
                }
                
            // }
        }
    }
}