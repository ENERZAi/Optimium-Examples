module core.List.List as ll
module common.uniontensor as ut
module micro.utils as mu
// let (isMain, passScale, setVars, loopOps, microOps, storeOps) = getMicroLayerImpl 

let isMain = true

let passScale input_scales output_scales = 
    let input1_scale = ll.item 0 input_scales
    let input2_scale = ll.item 1 input_scales
    let output_scale = ll.item 0 output_scales

    if(ut.isEmpty input1_scale){
        ([1.f], 32, true)
    } else{
        let si1 = ut.toCtTensorF32 input1_scale
        let si2 = ut.toCtTensorF32 input2_scale
        let so = ut.toCtTensorF32 output_scale

        ([si1 / so; si2 / so], 16, false)
    }

let setVars layer_param input_data input_shapes input_zero_points output_shapes output_zero_points input_edges output_edges input_tomains output_tomains input_towhichedges output_towhichedges ismain prefix accumscale = 
    print("micro.add.setVars")
    mu.baseBinaryOpSetVars layer_param input_data input_shapes input_zero_points output_shapes output_zero_points input_edges output_edges input_tomains output_tomains input_towhichedges output_towhichedges ismain prefix accumscale

let loopOps layer_param input_shapes input_dtypes input_zero_points output_shapes output_dtypes output_zero_points output_towhichedges prefix =
    // not implemented
    let impl outputnames nextop =
        nextop
    impl

let microOps layer_param input_data input_shapes input_edges output_edges input_tomains output_tomains ismain prefix = 
    print("micro.add.microOps")
    // quantization will be supported
    let isempty1 = ut.isEmpty (ll.item 0 input_data)
    let isempty2 = ut.isEmpty (ll.item 1 input_data)
    let ismaininput1 = ll.item 0 input_tomains
    let ismaininput2 =  ll.item 1 input_tomains
    let impl inputvectorname outputvectorname vectorstartidxlist vectorsize vectordtype nextop = 
        if(ismain){
            nextop
        } else{
            let inputvector1 = 
                if(isempty1 && ismaininput1){
                    let vectorname = inputvectorname // ll.item 0 inputvectorlist
                    !{${vectorname}}
                } else{
                    let varname = mu.getvarname prefix 0
                    !{${varname}[${mu.toVectorRangeRtTuple vectorstartidxlist vectorsize}]}
                }
            let inputvector2 = 
                if(isempty2 && ismaininput2){
                    let vectorname = inputvectorname // ll.item 1 inputvectorlist
                    !{${vectorname}}
                } else{
                    let varname = mu.getvarname prefix 1
                    let datashape = ll.item 1 input_shapes
                    if(ll.len datashape == 1){
                        let newidxlist = (
                            let rec impl index =
                                if(ll.len vectorstartidxlist == index){
                                    []
                                } else{
                                    !{0}; impl (index + 1)
                                }
                            impl 0
                        )
                        !{${varname}[${mu.toVectorRangeRtTuple newidxlist 1}]}
                    } else{
                        !{${varname}[${mu.toVectorRangeRtTuple vectorstartidxlist vectorsize}]}
                    }
                }
            let outputvector = (
                let vectorname = outputvectorname // ll.item 0 outputvectorlist
                !{${vectorname}}
            )
            if(inputvectorname == outputvectorname){
                !{
                    ${outputvector} <- ${inputvector1} + ${inputvector2}
                    ${nextop}
                }
            } else{
                !{
                    let ${outputvector} = ${inputvector1} + ${inputvector2}
                    ${nextop}
                }
            }
        }

    impl

let storeOps =  
    // not implemented
    let impl nextop =
        nextop
    impl

let mapIdxCtOps layer_param input_shapes output_shapes =
    let impl idxlist isflatten = 
        idxlist
    impl

let padOps layer_param input_shapes output_shapes = 
    mu.basePadOps layer_param input_shapes output_shapes

let microImpl = (isMain, passScale, setVars, loopOps, microOps, storeOps, padOps)

_end_