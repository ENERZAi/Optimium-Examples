module core.List.List as ll
module common.uniontensor as ut
module micro.utils as mu
// let (isMain, passScale, setVars, loopOps, microOps, storeOps) = getMicroLayerImpl

let isMain = false

let passScale input_scales output_scales =
    let input_scale = ll.item 0 input_scales
    let output_scale = ll.item 0 output_scales

    if(ut.isEmpty input_scale){
        ([1.f], 32, true)
    } else{
        let si = ut.toCtTensorF32 input_scale
        let so = ut.toCtTensorF32 output_scale

        ([si / so], 16, true)
    }

let setVars layer_param input_data input_shapes input_zero_points output_shapes output_zero_points input_edges output_edges input_tomains output_tomains input_towhichedges output_towhichedges ismain prefix accumscale = 
    mu.baseNotMainSetVars layer_param input_data input_shapes input_zero_points output_shapes output_zero_points input_edges output_edges input_tomains output_tomains input_towhichedges output_towhichedges ismain prefix accumscale

let loopOps layer_param input_shapes input_dtypes input_zero_points output_shapes output_dtypes output_zero_points output_towhichedges prefix =
    // not implemented
    let impl outputnames nextop =
        nextop
    impl

let microOps layer_param input_data input_shapes input_edges output_edges input_tomains output_tomains ismain prefix = 
    // quantization will be supported
    let impl inputvectorname outputvectorname vectorstartidxlist vectorsize vectordtype nextop =
        let inputvector = inputvectorname
        let outputvector = outputvectorname

        let get_constants size =
            if (vectordtype == rtType(f32)) {
                !{
                    let c2 = tensor((${size},), -0.5f32)
                    let c4 = tensor((${size},), 0.0416666679084300994873046875f32)
                    let c6 = tensor((${size},), -0.00138893374241888523101806640625f32)
                    let c8 = tensor((${size},), 0.00002531634891056455671787261962890625f32)
                    let c10 = tensor((${size},), -0.00000217334536500857211649417877197265625f32)
                    let one = tensor((${size},), 1.0f32)
                    (&c2, &c4, &c6, &c8, &c10, &one)
                }
            } else if (vectordtype == rtType(f16)) {
                !{
                    let c2 = tensor((${size},), -0.5f16)
                    let c4 = tensor((${size},), 0.041656494140625f16)
                    let c6 = tensor((${size},), -0.0011749267578125f16)
                    let c8 = tensor((${size},), -0.00106525421142578125f16)
                    let one = tensor((${size},), 1.0f16)
                    (&c2, &c4, &c6, &c8, &one)
                }
            } else {
                except("unsupported type: only f32, f16 supported")
            }

        let calculate_cos =
            if (vectordtype == rtType(f32)) {
                !{
                    let x = ${inputvector}
                    let x_square = x * x

                    let mut p = c10 * x_square + c8
                    p <- p * x_square + c6
                    p <- p * x_square + c4
                    p <- p * x_square + c2
                    p <- p * x_square + one

                    &p
                }
            } else if (vectordtype == rtType(f16)) {
                !{
                    let x = ${inputvector}
                    let x_square = x * x

                    let mut p = c8 * x_square + c6
                    p <- p * x_square + c4
                    p <- p * x_square + c2
                    p <- p * x_square + one

                    &p
                }
            } else {
                except("unsupported type: only f32, f16 supported")
            }

        let last_expr =
            if (inputvectorname == outputvectorname) {
                !{
                    ${outputvector} <- result
                    ${nextop}
                }
            } else {
                !{
                    let ${outputvector} = result
                    ${nextop}
                }
            }

        if (vectordtype == rtType(f32)) {
            !{
                let (c2, c4, c6, c8, c10, one) = ${get_constants vectorsize}
                let result = ${calculate_cos}

                ${last_expr}
            }
        } else {
            !{
                let (c2, c4, c6, c8, one) = ${get_constants vectorsize}
                let result = ${calculate_cos}

                ${last_expr}
            }
        }

    impl

let storeOps =
    // not implemented
    let impl nextop =
        nextop
    impl

let mapIdxCtOps layer_param input_shapes output_shapes =
    let impl idxlist isflatten =
        idxlist
    impl

let padOps layer_param input_shapes output_shapes =
    mu.basePadOps layer_param input_shapes output_shapes

let microImpl = (isMain, passScale, setVars, loopOps, microOps, storeOps, padOps)

_end_
