module core.List.List as ll
module common.uniontensor as ut
module micro.utils as mu
// let (isMain, passScale, setVars, loopOps, microOps, storeOps) = getMicroLayerImpl 

let isMain = true

let passScale input_scales output_scales = 
    let input1_scale = ll.item 0 input_scales
    let input2_scale = ll.item 1 input_scales
    let output_scale = ll.item 0 output_scales

    if(ut.isEmpty input1_scale){
        ([1.f], 32, true)
    } else{
        let si1 = ut.toCtTensorF32 input1_scale
        let si2 = ut.toCtTensorF32 input2_scale
        let so = ut.toCtTensorF32 output_scale

        ([si1 / so; si2 / so], 16, false)
    }

let setVars layer_param input_data input_shapes input_zero_points output_shapes output_zero_points input_edges output_edges input_tomains output_tomains input_towhichedges output_towhichedges ismain prefix accumscale = 
    print("micro.sub.setVars")
    // mu.baseBinaryOpSetVars layer_param input_data input_shapes input_zero_points output_shapes output_zero_points input_edges output_edges input_tomains output_tomains input_towhichedges output_towhichedges ismain prefix accumscale
    let impl inputnames outputnames inputshapes outputshapes ismutinputs nextop =
        let rec setinputs index nextvar = 
            if(index == (ll.len input_data)){
                nextvar
            } else{
                let data = ll.item index input_data
                let datashape = ll.item index input_shapes
                let folder a b = a * b
                let flattenshape = [ll.fold folder 1 datashape]
                let (layer, edge) = ll.item index input_edges
                let ismaininput = ll.item index input_tomains
                let representative_inputshape = ll.item 0 inputshapes
                let representative_outputshape = ll.item 0 outputshapes
                if((layer == -1) && (ismaininput) && (ut.isEmpty data)){ // set main input
                    let mainedge = ll.item index input_towhichedges
                    let inputname = ll.item mainedge inputnames
                    let inputshape = ll.item mainedge inputshapes
                    let ismut = ll.item mainedge ismutinputs
                    if(ismut){
                        !{
                            let mut ${inputname} = reshapeTo(${ll.toRtTuple inputshape}, &inputs[|${edge}|])
                            ${setinputs (index + 1) nextvar}
                        }
                    } else{
                        !{
                            let ${inputname} = reshapeTo(${ll.toRtTuple inputshape}, inputs[|${edge}|])
                            ${setinputs (index + 1) nextvar}
                        }
                    }
                } else if(!(ut.isEmpty data)){ // set micro constant
                    let varname = 
                        if(ismain){
                            ll.item index inputnames
                        } else{
                            mu.getvarname prefix index 
                        }
                    let dataexpr x = 
                        if(ismain){
                            let varshape = ll.toRtTuple(ll.item index inputshapes)
                            !{reshapeTo(${varshape}, ${-x})}
                        } else{
                            if(ll.len (ll.item index input_shapes) == 1){
                                let varshape = (
                                    let rec impl index =
                                        if(index == ll.len representative_inputshape){
                                            []
                                        } else{
                                            1; impl (index + 1)
                                        }
                                    ll.toRtTuple(impl 0)
                                )
                                !{reshapeTo(${varshape}, ${-x})}
                            }else if(ll.len representative_inputshape == 1){ // flatten
                                let varshape = ll.toRtTuple(flattenshape)
                                !{reshapeTo(${varshape}, ${-x})}
                            } else{
                                let varshape = ll.toRtTuple(ll.item index inputshapes)
                                !{reshapeTo(${varshape}, ${-x})}
                            }
                        }
                    let vardata = 
                        match data with
                            | ut.TensorI8 x    -> dataexpr x
                            | ut.TensorF16 x   -> dataexpr x
                            | ut.TensorF32 x   -> dataexpr x
                    !{
                        let ${varname} = ${vardata}
                        ${setinputs (index + 1) nextvar}
                    }
                } else if((layer == -1)){ // set micro input
                    let varname = mu.getvarname prefix index
                    let dataexpr x = 
                        if((ll.len representative_inputshape) == 1){ // flatten
                            let varshape = ll.toRtTuple(flattenshape)
                            !{reshapeTo(${varshape}, ${x})}
                        } else{
                            let varshape = ll.toRtTuple(representative_outputshape) // will be problem
                            !{reshapeTo(${varshape}, ${x})}
                        }
                    let vardata = dataexpr (!{&inputs[|${edge}|]})
                    !{
                        let mut ${varname} = ${vardata}
                        ${setinputs (index + 1) nextvar}
                    }
                } else{
                    setinputs (index + 1) nextvar
                }
            }
        let setoutputs nextvar = (
            let (layer, edge) = ll.item 0 output_edges
            let ismainoutput  = ll.item 0 output_tomains
            if((layer == -1) && (ismainoutput)){
                let mainedge = ll.item 0 output_towhichedges
                let outputname = ll.item mainedge outputnames
                let outputshape = ll.item mainedge outputshapes
                !{
                    let mut ${outputname} = reshapeTo(${ll.toRtTuple outputshape}, &outputs[|${edge}|])
                    ${nextvar}
                }
            } else{
                nextvar
            }
        )
        // quantization will be supported
        // let setmultshift nextop =
        setinputs 0 (setoutputs nextop)
    impl

let loopOps layer_param input_shapes input_dtypes input_zero_points output_shapes output_dtypes output_zero_points output_towhichedges prefix =
    // not implemented
    let impl outputnames nextop =
        nextop
    impl

let microOps layer_param input_data input_shapes input_edges output_edges input_tomains output_tomains ismain prefix = 
    print("micro.sub.microOps")
    // quantization will be supported
    let isempty1 = ut.isEmpty (ll.item 0 input_data)
    let isempty2 = ut.isEmpty (ll.item 1 input_data)
    let ismaininput1 = ll.item 0 input_tomains
    let ismaininput2 = ll.item 1 input_tomains
    let impl inputvectorname outputvectorname vectorstartidxlist vectorsize vectordtype nextop = 
        if(ismain){
            nextop
        } else{
            let inputvector1 = 
                if(isempty1 && ismaininput1){
                    let vectorname = inputvectorname // ll.item 0 inputvectorlist
                    !{${vectorname}}
                } else{
                    let varname = mu.getvarname prefix 0
                    !{${varname}[${mu.toVectorRangeRtTuple vectorstartidxlist vectorsize}]}
                }
            let inputvector2 = 
                if(isempty2 && ismaininput2){
                    let vectorname = inputvectorname // ll.item 1 inputvectorlist
                    !{${vectorname}}
                } else{
                    let varname = mu.getvarname prefix 1
                    let datashape = ll.item 1 input_shapes
                    if(ll.len datashape == 1){
                        let newidxlist = (
                            let rec impl index =
                                if(ll.len vectorstartidxlist == index){
                                    []
                                } else{
                                    !{0}; impl (index + 1)
                                }
                            impl 0
                        )
                        !{${varname}[${mu.toVectorRangeRtTuple newidxlist 1}]}
                    } else{
                        !{${varname}[${mu.toVectorRangeRtTuple vectorstartidxlist vectorsize}]}
                    }
                }
            let outputvector = (
                let vectorname = outputvectorname // ll.item 0 outputvectorlist
                !{${vectorname}}
            )
            if(inputvectorname == outputvectorname){
                if(isempty2){
                    !{
                        ${outputvector} <- ${inputvector1} - ${inputvector2}
                        ${nextop}
                    }
                } else{

                    !{
                        ${outputvector} <- ${inputvector1} + ${inputvector2}
                        ${nextop}
                    }
                }
            } else{
                !{
                    let ${outputvector} = ${inputvector1} - ${inputvector2}
                    ${nextop}
                }
            }
        }

    impl

let storeOps =  
    // not implemented
    let impl nextop =
        nextop
    impl

let mapIdxCtOps layer_param input_shapes output_shapes =
    let impl idxlist isflatten = 
        idxlist
    impl

let padOps layer_param input_shapes output_shapes = 
    mu.basePadOps layer_param input_shapes output_shapes

let microImpl = (isMain, passScale, setVars, loopOps, microOps, storeOps, padOps)

_end_