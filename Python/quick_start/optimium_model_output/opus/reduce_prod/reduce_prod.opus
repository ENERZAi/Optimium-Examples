module core.List.List as ll
module reduce.utils as u
module common.utils as commonutils
module common.uniontensor as ut
module common.params as params

template</attr_params: params.Attributes, optim_params: params.Optimization, layer_params: ll.List<params.Layerargs>,
    input_data: ll.List<ll.List<ut.UnionTensor>>, input_dtypes: ll.List<ll.List<rtType>>, input_shapes: ll.List<ll.List<i32>>, input_scales: ll.List<ll.List<ut.UnionTensor>>, input_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    output_dtypes: ll.List<ll.List<rtType>>, output_shapes: ll.List<ll.List<i32>>, output_scales: ll.List<ll.List<ut.UnionTensor>>, output_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    input_edges: ll.List<ll.List<tuple<i32, i32>>>, output_edges: ll.List<ll.List<tuple<i32, i32>>>, ismainops: ll.List<boolean>,
    input_t: rtType, input_rt_list : ll.List<rtType>,  output_t: rtType, output_rt_list : ll.List<rtType>/>
attr[Extern : attr_params->name, Optimization : { VectorSize : 512 }]
fun reduce_prod(input: input_t, mut &output: output_t) -> i32 {
    ${
        let layerindex = (
            let mut index = 0
            for(i from 0 to (ll.len layer_params)){
                match (ll.item i layer_params) with 
                    | params.Reduce_prod x   -> if((ll.item i ismainops)){index <- i} else{_end_}
                    | _                 -> _end_
            }
            index
        )

        let layerparams = 
            match (ll.item layerindex layer_params) with 
                | params.Reduce_prod x -> x

        let input_dtype = ll.item 0 (ll.item layerindex input_dtypes)
        let input_shape = ll.item 0 (ll.item layerindex input_shapes)
        let input_scales = ll.item 0 (ll.item layerindex input_scales)
        let input_zero_points = ll.item 0 (ll.item layerindex input_zero_points)
        let output_shape = ll.item 0 (ll.item layerindex output_shapes)
        let output_scales = ll.item 0 (ll.item layerindex output_scales)
        let output_zero_points = ll.item 0 (ll.item layerindex output_zero_points)   

        let tmpPack = ll.item 0 (optim_params->pack)
        let tmpUnroll = ll.item 0 (optim_params->unroll)
        let input_dim = ll.len <| input_shape
        let axis = layerparams->dim
        let keepdims = layerparams->keepdim
        // let axes = match axis with
        //             | commonutils.None -> ll.reverse <| (u.createIncList <| [] <| (input_dim - 1))
        //             | commonutils.Value lst -> lst
        let axes = axis
        let num_axes = ll.len <| axes
        let max_reduction_axis = ll.item <| (num_axes - 1) <| axes
        let last_consec_parallel_axis = 
            if (max_reduction_axis == (input_dim - 1)) {
                -1
            } else {
                max_reduction_axis + 1
            }
        if (last_consec_parallel_axis >= 0) {
            let last_consec_parallel_num = (ll.len <| input_shape) - last_consec_parallel_axis
            let last_parallel_size = 
                let folder s e = s * e
                let parallel_shapes = u.get_list_slice <| ((ll.len <| output_shape) - last_consec_parallel_num) <| (ll.len <| output_shape) <| output_shape
                ll.fold folder 1 parallel_shapes

            let pack = if ((last_parallel_size % tmpPack) == 0) {
                tmpPack
            } else {
                ll.item <| ((ll.len <| input_shape) - 1) <| input_shape
            }

            let reduce_indices =
                u.extract_elems_by_indices <| axes <| input_shape
            let outer_indices = 
                u.get_list_slice <| 0 <| ((ll.len <| output_shape) - last_consec_parallel_num) <| output_shape
            let input_iters = 
                let partial_input = u.get_list_slice <| 0 <| ((ll.len <| input_shape) - last_consec_parallel_num) <| input_shape
                u.get_input_indices <| partial_input <| axes <| pack <| keepdims
            let output_access =
                let partial_input = u.get_list_slice <| 0 <| ((ll.len <| input_shape) - last_consec_parallel_num) <| input_shape
                let result = u.get_output_access <| partial_input <| axes <| keepdims <| pack
                if ((ll.len <| result) == 0) {
                    [0]
                } else {
                    result
                }
            
            let output_packed_shape = ll.concat <| outer_indices <| [(last_parallel_size / pack) ; pack]
            let input_packed_shape = 
                ll.concat <| (u.get_list_slice <| 0 <| ((ll.len <| input_shape) - last_consec_parallel_num) <| input_shape) <| [(last_parallel_size / pack) ; pack]
            !{
                let input_reshaped = reshapeTo(${ll.toRtTuple <| input_packed_shape}, input[|0|])
                let mut output_reshaped = reshapeTo(${ll.toRtTuple <| output_packed_shape}, &output[|0|])
                ${
                    let rec out_iter idx =
                        if (idx == 0){
                            !{
                                for(${"idx" + toStr(idx)} from 0 to ${ll.item <| idx <| outer_indices}) {
                                    ${
                                        if (idx == ((ll.len <| outer_indices) - 1)) {
                                            !{
                                                for (p from 0 to ${(last_parallel_size / pack)}) {
                                                    let mut vec = tensor((${pack},), 1.0f)
                                                    ${
                                                        let rec reduce_iter r_idx = 
                                                            if(r_idx == 0){
                                                                !{
                                                                    for(${"r_idx" + toStr(r_idx)} from 0 to ${ll.item <| r_idx <| reduce_indices}) {
                                                                        ${
                                                                            if (r_idx == (num_axes - 1)){
                                                                                !{
                                                                                    vec <- vec * input_reshaped[${(ll.toRtTuple <| input_iters)}]
                                                                                }
                                                                            } else {
                                                                                reduce_iter (r_idx + 1)
                                                                            }
                                                                        }
                                                                    }
                                                                    output_reshaped[${ll.toRtTuple <| output_access}] <- vec
                                                                }
                                                            } else {
                                                                !{
                                                                    for(${"r_idx" + toStr(r_idx)} from 0 to ${ll.item <| r_idx <| reduce_indices}) {
                                                                        ${
                                                                            if (r_idx == (num_axes - 1)){
                                                                                !{
                                                                                    vec <- vec * input_reshaped[${(ll.toRtTuple <| input_iters)}]
                                                                                }
                                                                            } else {
                                                                                reduce_iter (r_idx + 1)
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        reduce_iter 0
                                                    }
                                                }
                                            } 
                                        } else {
                                            !{
                                                ${out_iter (idx + 1)}
                                            }
                                        }
                                    }
                                }
                                0
                            }
                        } else {
                            !{
                                for(${"idx" + toStr(idx)} from 0 to ${ll.item <| idx <| outer_indices}) {
                                    ${
                                        if (idx == ((ll.len <| outer_indices) - 1)) {
                                            !{
                                                for (p from 0 to ${(last_parallel_size / pack)}) {
                                                    let mut vec = tensor((${pack},), 1.0f)
                                                    ${
                                                        let rec reduce_iter r_idx = 
                                                            if(r_idx == 0){
                                                                !{
                                                                    for(${"r_idx" + toStr(r_idx)} from 0 to ${ll.item <| r_idx <| reduce_indices}) {
                                                                        ${
                                                                            if (r_idx == (num_axes - 1)){
                                                                                !{
                                                                                    vec <- vec * input_reshaped[${(ll.toRtTuple <| input_iters)}]
                                                                                }
                                                                            } else {
                                                                                reduce_iter (r_idx + 1)
                                                                            }
                                                                        }
                                                                    }
                                                                    output_reshaped[${ll.toRtTuple <| output_access}] <- vec
                                                                }
                                                            } else {
                                                                !{
                                                                    for(${"r_idx" + toStr(r_idx)} from 0 to ${ll.item <| r_idx <| reduce_indices}) {
                                                                        ${
                                                                            if (r_idx == (num_axes - 1)){
                                                                                !{
                                                                                    vec <- vec * input_reshaped[${(ll.toRtTuple <| input_iters)}]
                                                                                }
                                                                            } else {
                                                                                reduce_iter (r_idx + 1)
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        reduce_iter 0
                                                    }
                                                }
                                            } 
                                        } else {
                                            !{
                                                ${out_iter (idx + 1)}
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    out_iter 0
                }
            }
        } else {
            let reduce_indices =
                u.extract_elems_by_indices <| axes <| input_shape
            let outer_indices = 
                u.get_list_slice <| 0 <| (ll.len <| output_shape) <| output_shape
            let input_iters = 
                u.get_input_indices_no_pack <| input_shape <| axes <| keepdims
            let output_access =
                let result = u.get_output_access_no_pack <| input_shape <| axes <| keepdims
                if ((ll.len <| result) == 0) {
                    [0]
                } else {
                    result
                }
            !{
                ${
                    let rec out_iter idx =
                        !{
                            for(${"idx" + toStr(idx)} from 0 to ${ll.item <| idx <| outer_indices}) {
                                ${
                                    if (idx == ((ll.len <| output_shape) - 1)) {
                                        !{
                                            let mut acc = 1.0f
                                            ${
                                                let rec reduce_iter r_idx = 
                                                    if(r_idx == 0){
                                                        !{
                                                            for(${"r_idx" + toStr(r_idx)} from 0 to ${ll.item <| r_idx <| reduce_indices}) {
                                                                ${
                                                                    if (r_idx == (num_axes - 1)){
                                                                        !{
                                                                            acc <- acc * input[${(ll.toRtTuple <| input_iters)}]
                                                                        }
                                                                    } else {
                                                                        reduce_iter (r_idx + 1)
                                                                    }
                                                                }
                                                            }
                                                            output[${ll.toRtTuple <| output_access}] <- acc
                                                        }
                                                    } else {
                                                        !{
                                                            for(${"r_idx" + toStr(r_idx)} from 0 to ${ll.item <| r_idx <| reduce_indices}) {
                                                                ${
                                                                    if (r_idx == (num_axes - 1)){
                                                                        !{
                                                                            acc <- acc * input[${(ll.toRtTuple <| input_iters)}]
                                                                        }
                                                                    } else {
                                                                        reduce_iter (r_idx + 1)
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                reduce_iter 0
                                            }
                                        } 
                                    } else {
                                        !{
                                            ${out_iter (idx + 1)}
                                        }
                                    }
                                }
                            }
                        }
                    out_iter 0
                }
            }
        }
    }
}