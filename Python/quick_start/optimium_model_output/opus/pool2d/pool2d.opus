module core.List.List as ll
module common.uniontensor as ut
module common.params as params
module pool2d.pool2dhelper as u

template</attr_params: params.Attributes, optim_params: params.Optimization, layer_params: ll.List<params.Layerargs>,
    input_data: ll.List<ll.List<ut.UnionTensor>>, input_dtypes: ll.List<ll.List<rtType>>, input_shapes: ll.List<ll.List<i32>>, input_scales: ll.List<ll.List<ut.UnionTensor>>, input_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    output_dtypes: ll.List<ll.List<rtType>>, output_shapes: ll.List<ll.List<i32>>, output_scales: ll.List<ll.List<ut.UnionTensor>>, output_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    input_edges: ll.List<ll.List<tuple<i32, i32>>>, output_edges: ll.List<ll.List<tuple<i32, i32>>>, ismainops: ll.List<boolean>,
    input_t: rtType, input_rt_list : ll.List<rtType>,  output_t: rtType, output_rt_list : ll.List<rtType>/>
attr[Extern : attr_params->name, Optimization : { VectorSize : 512 }]
fun pool2d(inputs : input_t, mut &outputs : output_t) -> i32 {
    ${
        print("pool2d compiletime")
        let layerindex = (
            let mut index = 0
            for(i from 0 to (ll.len layer_params)){
                match (ll.item i layer_params) with 
                    | params.Pool2d x   -> index <- i
                    | _                 -> _end_
            }
            index
        )
        let thislayer_params = 
            match (ll.item layerindex layer_params) with
                | params.Pool2d x -> x

        let input_dtype = ll.item 0 (ll.item layerindex input_dtypes)
        let input_shape = ll.item 0 (ll.item layerindex input_shapes)
        let input_scale = ll.item 0 (ll.item layerindex input_scales)
        let input_zero_point = ll.item 0 (ll.item layerindex input_zero_points)
        let output_dtype = ll.item 0 (ll.item layerindex output_dtypes)
        let output_shape = ll.item 0 (ll.item layerindex output_shapes)
        let output_scale = ll.item 0 (ll.item layerindex output_scales)
        let output_zero_point = ll.item 0 (ll.item layerindex output_zero_points)

        // let weight = ll.item 1 (ll.item 0 input_data)
        // let weight_shape = ll.item 1 (ll.item 0 input_shapes)
        // let weight_scales = ll.item 1 (ll.item 0 input_scales)
        // let weight_zero_points = ll.item 1 (ll.item 0 input_zero_points)

        let framework = thislayer_params->framework
        // let nchw = thislayer_params->nchw
        let pooltype = thislayer_params->pooltype
        let stride = thislayer_params->stride
        let pool_size = thislayer_params->kernel_size
        let padding = thislayer_params->padding
        let dilation = thislayer_params->dilation
        let return_indices = thislayer_params->return_indices
        
        let pack = (ll.item 0 (optim_params->pack), ll.item 1 (optim_params->pack))
        let unroll = (ll.item 0 (optim_params->unroll), ll.item 1 (optim_params->unroll), ll.item 2 (optim_params->unroll), ll.item 3 (optim_params->unroll))
        let (packinch, packoutch) = pack
        let (unrollrow, unrollcol, unrollinch, unrolloutch) = unroll
        // let nchw = optim_params->nchw
        let nchw = false

        let input_shape_tuple = (ll.item 0 input_shape, ll.item 1 input_shape, ll.item 2 input_shape, ll.item 3 input_shape)
        let output_shape_tuple = (ll.item 0 output_shape, ll.item 1 output_shape, ll.item 2 output_shape, ll.item 3 output_shape)
        let weight_shape_tuple = (0, 0, 0, 0)
        let (_, outrows, outcols, outch) = output_shape_tuple

        let _ = if(unrollrow > 1){
            // except("unroll along output row axis(" + toStr(unrollrow) + ") should be smaller than outrows(" + toStr(outrows) + ")")
            except("unroll along output row axis(" + toStr(unrollrow) + ") should be 1")
        } else if(unrollcol > 1){
            except("unroll along output col axis(" + toStr(unrollcol) + ") should be 1")
        } else{
            _end_
        }

        let _ = if(packoutch * unrolloutch > outch){
            except("output channel(" + toStr(outch) + ") should be bigger than packoutch * unrolloutch(" + toStr(packoutch * unrolloutch) + ")")
        } else{
            _end_
        }

        let _ = if(packinch != 1 && packinch != packoutch){
            except("pack input channel(" + toStr(packinch) + ") should be 1 or same with packoutch(" + toStr(packoutch) + ")")
        } else{
            _end_
        }

        let weight = if(input_dtype == rtType(i8)){
            ut.TensorI8(tensor((1,), 0i8))
        } else if(input_dtype == rtType(f16)){
            ut.TensorF16(tensor((1,), 0.f16))
        } else if(input_dtype == rtType(f32)){
            ut.TensorF32(tensor((1,), 0.f32))
        } else{
            except("input_dtype should be the one of int8, float16, float32")
        }

        let templateparams = u.TemplateParameters(
            attr_params, optim_params, layer_params,
            input_data, input_dtypes, input_shapes, input_scales, input_zero_points,
            output_dtypes, output_shapes, output_scales, output_zero_points,
            input_edges, output_edges, ismainops,
            input_rt_list, output_rt_list
            )
        let internalparams = u.InternalParameters(
            pooltype, pool_size, stride, padding, (1, 1),
            input_t, input_dtype, input_shape_tuple, input_scale, input_zero_point, 
            output_t, output_dtype, output_shape_tuple, output_scale, output_zero_point, 
            weight,
            framework, nchw, pack, unroll
        )

        if(pooltype == "avgpool2d"){
            let params = u.initCodeGen templateparams internalparams
            let idxs = u.Indexes(0, 0, 0)
            // let tree =  u.Op(u.setBatchInputOutputExpr,
            //             u.Op(u.setInputpatternExpr,
            //             u.Op(u.setMultShiftExpr,
            //             u.Op(u.setZeropointsExpr,
            //             u.Op(u.setPadExpr,
            //             u.Block(u.batchLoopExpr,
            //                 u.Block(u.tiledInputPatternLoopExpr,
            //                     u.Block(u.tiledOutputChannelLoopExpr,
            //                         u.Op(u.unrolledLoadSumExpr,
            //                         u.Op(u.unrolledSetInputpatternidxExpr,
            //                         u.Op(u.unrolledSetDivExpr,
            //                         u.Block(u.weightLoopExpr,
            //                             u.Op(u.unrolledInputSubviewExpr,
            //                             u.Op(u.unrolledLoadInputAndPoolExpr,
            //                             u.Op(u.unrolledUpdateInputpatternidxExpr,
            //                             u.End(u.endExpr)))),
            //                         u.Op(u.unrolledStoreExpr,
            //                         u.End(u.endExpr)))))),
            //                     u.End(u.endExpr)),
            //                 u.End(u.endExpr)),
            //             u.End(u.zeroExpr)))))))
            let tree =  u.Op(u.setBatchInputOutputExpr,
                        u.Op(u.setInputpatternExpr,
                        u.Op(u.setMultShiftExpr,
                        u.Op(u.setZeropointsExpr,
                        u.Op(u.setPadExpr,
                        u.Block(u.batchLoopExpr,
                            u.Block(u.tiledInputPatternLoopExpr,
                                u.Op(u.unrolledSetInputidxAndDivExpr,
                                u.Block(u.tiledOutputChannelLoopExpr,
                                    u.Op(u.unrolledLoadSumExpr,
                                    u.Op(u.unrolledLoadInputAndPool2Expr,
                                    u.Op(u.unrolledStore2Expr,
                                    u.End(u.endExpr)))),
                                u.End(u.endExpr))),
                            u.End(u.endExpr)),
                        u.End(u.zeroExpr)))))))

            u.genRuntimeCode params idxs tree
        } else if(pooltype == "maxpool2d"){
            let params = u.initCodeGen templateparams internalparams
            let idxs = u.Indexes(0, 0, 0)
            // let tree =  u.Op(u.setBatchInputOutputExpr,
            //             u.Op(u.setInputpatternExpr,
            //             u.Op(u.setPadExpr,
            //             u.Block(u.batchLoopExpr,
            //                 u.Block(u.tiledInputPatternLoopExpr,
            //                         u.Block(u.tiledOutputChannelLoopExpr,
            //                         u.Op(u.unrolledLoadSumExpr,
            //                         u.Op(u.unrolledSetInputpatternidxExpr,
            //                         u.Block(u.weightLoopExpr,
            //                             u.Op(u.unrolledInputSubviewExpr,
            //                             u.Op(u.unrolledLoadInputAndPoolExpr,
            //                             u.Op(u.unrolledUpdateInputpatternidxExpr,
            //                             u.End(u.endExpr)))),
            //                         u.Op(u.unrolledStoreExpr,
            //                         u.End(u.endExpr))))),
            //                     u.End(u.endExpr)),
            //                 u.End(u.endExpr)),
            //             u.End(u.zeroExpr)))))
            let tree =  u.Op(u.setBatchInputOutputExpr,
                        u.Op(u.setInputpatternExpr,
                        u.Op(u.setPadExpr,
                        u.Block(u.batchLoopExpr,
                            u.Block(u.tiledInputPatternLoopExpr,
                                u.Op(u.unrolledSetInputidxAndDivExpr,
                                u.Block(u.tiledOutputChannelLoopExpr,
                                    u.Op(u.unrolledLoadSumExpr,
                                    u.Op(u.unrolledLoadInputAndPool2Expr,
                                    u.Op(u.unrolledStore2Expr,
                                    u.End(u.endExpr)))),
                                u.End(u.endExpr))),
                            u.End(u.endExpr)),
                        u.End(u.zeroExpr)))))

            u.genRuntimeCode params idxs tree
        } else{
            except("pooltype must be one of (avgpool2d, maxpool2d)")
        }

    }
}

_end_