module core.List.List as ll
module common.utils as commonutils
module interpolate.utils as bu
module common.uniontensor as ut

let rec setCoordExpr_impl index params spatial_dims nextOp =
    if(index == (spatial_dims-1i)){
        !{
            let ${params->lowcoord_prefix+toStr(index)} = ${
                (ll.item <| index <| params->coordlist)[|0i|]
            }
            let ${params->highcoord_prefix+toStr(index)} = ${
                (ll.item <| index <| params->coordlist)[|1i|]
            }
            let ${params->coeff_prefix+toStr(index)} = ${
                let tns = (ll.item <| index <| params->coordlist)[|2i|]
                ut.toRtTensor <| tns
            }
            ${nextOp}
        }
        
    } else{
        !{
            let ${params->lowcoord_prefix+toStr(index)} = ${
                (ll.item <| index <| params->coordlist)[|0i|]
            }
            let ${params->highcoord_prefix+toStr(index)} = ${
                (ll.item <| index <| params->coordlist)[|1i|]
            }
            let ${params->coeff_prefix+toStr(index)} = ${
                let tns = (ll.item <| index <| params->coordlist)[|2i|]
                ut.toRtTensor <| tns
            }
            ${
                setCoordExpr_impl <| (index + 1i) <| params <| spatial_dims <| nextOp
            }
        }
    }

let setCoordExpr params spatial_dims nextOp =
    setCoordExpr_impl <| 0i <| params <| spatial_dims <| nextOp


let genRectanglePointAccess dims nums vec unroll params nextop =
    // dims - spatial dims
    // nums - 2 ** dims
   
    let genRectanlgePointAccess_RtExpr index unrollindex nextop =
        let rec get_remainder_index remainnum first_no_remainder steps =
            // 0 -> return [0,0,0,0] with first_no_remainder -1 when dims = 4
            // 5 -> return [1,0,1,0] with first_no_remainder 0 when dims = 4
            // initial value : remainnum -> index, first_no_remainder -> -1, steps -> 0
            if (steps == dims){
                ([], first_no_remainder)
            } else{
                let remain = (remainnum % 2i)
                let newremainnum = (remainnum - remain) / 2
                let (remainder_from_next, first_no_remainder_from_next)  = get_remainder_index <| newremainnum <| first_no_remainder <| (steps + 1i)
                if (remain == 1i){
                    if (first_no_remainder >= 0i){
                        (ll.concat <| [remain] <| remainder_from_next, first_no_remainder)
                    } else{
                        (ll.concat <| [remain] <| remainder_from_next, steps)
                    }
                } else{
                    if (first_no_remainder >= 0i){
                        (ll.concat <| [remain] <| remainder_from_next, first_no_remainder)
                    } else{
                        (ll.concat <| [remain] <| remainder_from_next, first_no_remainder_from_next)
                    }
                }
            }

        let (remainder, first_nonzero_index) = get_remainder_index <| index <| (-1i) <| 0i
    
        let rec get_RtList remainder first_nonzero_index lower_first_nonzero steps =
            if (steps == (ll.len <| remainder)){
                []
            } else{
                if (lower_first_nonzero){
                    if(steps == first_nonzero_index){
                        ll.concat <| [!{${params->lowcoord_prefix+toStr(steps)}[(${params->flatten_idxname + "_" + toStr(steps)},)]}] <| (get_RtList <| remainder <| first_nonzero_index <| lower_first_nonzero <| (steps+1i))
                    } else{
                        if((ll.item <| steps <| remainder) == 1i){
                            // high
                            ll.concat <| [!{${params->highcoord_prefix+toStr(steps)}[(${params->flatten_idxname + "_" + toStr(steps)},)]}] <| (get_RtList <| remainder <| first_nonzero_index <| lower_first_nonzero <| (steps+1i))
                        } else{
                            // low
                            ll.concat <| [!{${params->lowcoord_prefix+toStr(steps)}[(${params->flatten_idxname + "_" + toStr(steps)},)]}] <| (get_RtList <| remainder <| first_nonzero_index <| lower_first_nonzero <| (steps+1i))
                        }
                    }
                } else{
                        if((ll.item <| steps <| remainder) == 1i){
                            // high
                            ll.concat <| [!{${params->highcoord_prefix+toStr(steps)}[(${params->flatten_idxname + "_" + toStr(steps)},)]}] <| (get_RtList <| remainder <| first_nonzero_index <| lower_first_nonzero <| (steps+1i))
                        } else{
                            // low
                            ll.concat <| [!{${params->lowcoord_prefix+toStr(steps)}[(${params->flatten_idxname + "_" + toStr(steps)},)]}] <| (get_RtList <| remainder <| first_nonzero_index <| lower_first_nonzero <| (steps+1i))
                        }
                    }
            }
        if(index == 0i){
            // Last channel dimension
            let positive_term_idx = (ll.concat <| [!{${params->batch_iter}}] <| (ll.concat <| (get_RtList <| remainder <| first_nonzero_index <| false <| 0i) <| [!{${params->channel_iter} + ${vec * unrollindex}:(${params->channel_iter}+${vec * (unrollindex+1)}):1 }] ))
            if(params->quant){
                !{
                    let ${params->inputaccess_prefix + toStr(index) + "_" + toStr(unrollindex)} = cast<i16>(batchinput[${ll.toRtTuple <| positive_term_idx}])
                    ${nextop}
                }            
            } else{
                !{
                    let ${params->inputaccess_prefix + toStr(index) + "_" + toStr(unrollindex)} = batchinput[${ll.toRtTuple <| positive_term_idx}]
                    ${nextop}
                }            
            }
            
        } else{
            let positive_term_idx = (ll.concat <| [!{${params->batch_iter}}] <| (ll.concat <| (get_RtList <| remainder <| first_nonzero_index <| false <| 0i) <| [!{${params->channel_iter} + ${vec * unrollindex}:(${params->channel_iter}+${vec * (unrollindex+1)}):1}] ))
            let negative_term_idx = (ll.concat <| [!{${params->batch_iter}}] <| (ll.concat <| (get_RtList <| remainder <| first_nonzero_index <| true <| 0i) <| [!{${params->channel_iter} + ${vec * unrollindex}:(${params->channel_iter}+${vec * (unrollindex+1)}):1}] ))
            if (params->quant){
                !{
                    let ${params->inputaccess_prefix + toStr(index) + "_" + toStr(unrollindex)} = cast<i16>(batchinput[${ll.toRtTuple <| positive_term_idx}]) - cast<i16>(batchinput[${ll.toRtTuple <| negative_term_idx}])
                    ${nextop}
                }
            } else{
                !{
                    let ${params->inputaccess_prefix + toStr(index) + "_" + toStr(unrollindex)} = (batchinput[${ll.toRtTuple <| positive_term_idx}]) - (batchinput[${ll.toRtTuple <| negative_term_idx}])
                    ${nextop}
                }
            }
            
        }

    let rec genRectanglePointAccess_impl index unrollindex nextop =
        if((index == nums) &&  (unrollindex == (unroll-1))){
            nextop
        } else if(index == nums){
            genRectanlgePointAccess_RtExpr <| 0 <| (unrollindex+1) <| (genRectanglePointAccess_impl <| 1 <| (unrollindex+1) <| nextop)
        } else{
            genRectanlgePointAccess_RtExpr <| index <| unrollindex <| (genRectanglePointAccess_impl <| (index+1i) <| unrollindex <| nextop)
        }


    genRectanglePointAccess_impl <| 0i <| 0i <|  nextop

let getDecimal lst =
    let rec getDecimal_impl index =
        if(index == (ll.len <| lst)){
            0i
        } else{
            ll.item <| index <| lst + 2i * (getDecimal_impl <| (index+1i))
        }
    getDecimal_impl <| 0i

let genAllterms dims nums unroll params nextop =
    // generate all terms
    // term0 = access0
    // term1 = access1
    let rec get_remainder_index remainnum steps =
        // 0 -> return [0,0,0,0] when dims = 4
        // 5 -> return [1,0,1,0] when dims = 4
        // initial value : remainnum -> index, steps -> 0
        if (steps == dims){
            ([], [])
        } else{
            let remain = (remainnum % 2i)
            let newremainnum = (remainnum - remain) / 2
            let (remainder_from_next, ones_index_from_next) = get_remainder_index <| newremainnum <| (steps + 1i)
            if (remain == 1i){
                (ll.concat <| [remain] <| remainder_from_next, ll.concat <| [steps] <| ones_index_from_next)
            } else{
                (ll.concat <| [remain] <| remainder_from_next, ll.concat <| [] <| ones_index_from_next)
            }
        }

    let rec modify_one_element index lst zeroindex =
        if(index == dims){
            []
        } else if (index == zeroindex){
            ll.concat <| [0i] <| (modify_one_element <| (index+1i) <| lst <| zeroindex)
        } else{
            ll.concat <| [ll.item <| index <| lst] <| (modify_one_element <| (index+1i) <| lst <| zeroindex)
        }
    let rec modify_various_elements lst zeroindex_list =
        if((ll.len <| zeroindex_list) == 0i){
            lst
        } else{
            let newlst = modify_one_element <| 0i <| lst <| (ll.item <| 0i <| zeroindex_list)
            modify_various_elements <| newlst <| (ll.drop <| 1i <| zeroindex_list)
        }

    let rec get_terms_list remainder_list ones_candidate_index storenum ones_num  =
        // take smallest "num" numbers with removing num elements whose value is one
        // [1,0,1,1] ones_num : 2, storenum : 2, ones_candidate_index [0,2,3] -> [ [1,0,0,0] , [0,0,1,0] ]
        if(ones_num == 0){
            let xprime = modify_various_elements <| remainder_list <| ones_candidate_index
            ([xprime], 1i)
        } else if(ones_num == (ll.len <| ones_candidate_index)){
            ([remainder_list], 1i)
        } else{
            let xprime = modify_one_element <| 0i <| remainder_list <| (ll.item <| 0i <| (ll.reverse <| ones_candidate_index))
            let candprime = ll.reverse <| (ll.drop <| 1i <| (ll.reverse <| ones_candidate_index))
            let (ans1, ansnum1) =  get_terms_list <| xprime <| candprime <| storenum <| ones_num
            if (ansnum1 < storenum){
                let candtwoprime = ll.reverse <| (ll.drop <| 1i <| (ll.reverse <| ones_candidate_index))
                let (ans2, ansnum2) = get_terms_list <| remainder_list <| candtwoprime <| (storenum - ansnum1) <| (ones_num -1i)
                (ll.concat <| ans1 <| ans2, ansnum1 + ansnum2)
            } else{
                (ans1, ansnum1)
            }
        }

    let genAllterms_RtExpr index unroll nextop =
        let (remainder_index, ones_index) = get_remainder_index index 0i
        let get_ones state h =
            if(h==1i)
                state + 1i
            else
                state
        let index_ones_num = (ll.fold <| get_ones <| 0i <| remainder_index)

        let rec get_one_term_rtexpr expr ones_num storenum plus =
            let (termindex_list, termnum) = get_terms_list <| remainder_index <| ones_index <| storenum <| ones_num
            let rec add_current_step_term curadded_index addedexpr =
                if(curadded_index == (ll.len <| termindex_list)) {
                    addedexpr
                } else{
                    let newaddedexpr = if(plus){
                        if(params->quant){
                            !{
                                ${addedexpr} + cast<i32>(${params->inputaccess_prefix+toStr( getDecimal <| (ll.item <| curadded_index <| termindex_list)) + "_" + toStr(unroll)})
                            }
                        } else{
                            !{
                                ${addedexpr} + ${params->inputaccess_prefix+toStr( getDecimal <| (ll.item <| curadded_index <| termindex_list)) + "_" + toStr(unroll)}
                            }
                        }
                    } else{
                        if(params->quant){
                            !{
                                ${addedexpr} - cast<i32>(${params->inputaccess_prefix+toStr( getDecimal <| (ll.item <| curadded_index <| termindex_list)) + "_" + toStr(unroll)})
                            }
                        } else{
                            !{
                                ${addedexpr} - ${params->inputaccess_prefix+toStr( getDecimal <| (ll.item <| curadded_index <| termindex_list)) + "_" + toStr(unroll)}
                            }
                        }
                        
                    }
                    add_current_step_term <| (curadded_index + 1i) <| newaddedexpr
                }        
            if(ones_num == 1i){
                add_current_step_term <| 0i <| expr
            } else{
                let newexpr = add_current_step_term <| 0i <| expr
                let newstorenum = (commonutils.combination <| index_ones_num <| (ones_num - 1i)) - termnum
                if(plus){
                    get_one_term_rtexpr <| newexpr <| (ones_num - 1i) <| newstorenum <| false
                } else{
                    get_one_term_rtexpr <| newexpr <| (ones_num - 1i) <| newstorenum <| true
                }
            }

        if(index_ones_num <= 1i){
            if (params->quant){
                !{
                    let ${params->inputterm_prefix+toStr(0)+"_"+toStr(index) + "_" + toStr(unroll)} = cast<i32>(${params->inputaccess_prefix+toStr(index) + "_" + toStr(unroll)})
                    ${nextop}
                }
            } else{
                !{
                    let ${params->inputterm_prefix+toStr(0)+"_"+toStr(index) + "_" + toStr(unroll)} = ${params->inputaccess_prefix+toStr(index) + "_" + toStr(unroll)}
                    ${nextop}
                }
            }
            
        } else{
            let first_storenum = (index_ones_num - 1i)
            let first_term = if(params->quant){
                !{cast<i32>(${params->inputaccess_prefix+toStr(index) + "_" + toStr(unroll)})}
            } else{
                !{${params->inputaccess_prefix+toStr(index) + "_" + toStr(unroll)}}
            }
            let term = get_one_term_rtexpr <| first_term <| (index_ones_num-1i) <| first_storenum <| false
            !{
                let ${params->inputterm_prefix+toStr(0)+"_"+toStr(index) + "_" + toStr(unroll)} = ${term}
                ${nextop}
            }
        }

    let rec genAllterms_impl index unrollindex nextop =
        if((index == nums) && (unrollindex == (unroll -1))){
            nextop
        } else if(index == nums){
            genAllterms_RtExpr <| 0 <| (unrollindex+1) <| (genAllterms_impl <| 1 <| (unrollindex+1) <| nextop)
        } else{
            genAllterms_RtExpr <| index <| unrollindex <| (genAllterms_impl <| (index + 1i) <| unrollindex <| nextop)
        }
    genAllterms_impl <| 0i <| 0i <| nextop

let genWeightedSum dims nums unroll params nextop =
    
    let genWeightedSum_RtExpr steps unroll nextop =
        let rec genWeightedSum_RtExpr_impl index =
            if(index == (1i<<(dims - steps - 1i))){
                nextop
            } else if (index == 0i){
                if(params->quant){
                    // TODO
                    !{
                        let ${params->coeffaccess_prefix+toStr(steps)} = ${params->coeff_prefix+toStr(steps)}[(${params->flatten_idxname + "_" + toStr(steps)}:${params->flatten_idxname + "_" + toStr(steps)}+1:1,)]
                        let ${params->inputterm_prefix+toStr(steps+1i)+"_"+toStr(index) + "_" + toStr(unroll)} = ${params->inputterm_prefix+toStr(steps)+"_"+toStr(index*2) + "_" + toStr(unroll)} * (1i << ${params->shiftbit}) + 
                                                ${params->coeffaccess_prefix+toStr(steps)} * ${params->inputterm_prefix+toStr(steps)+"_"+toStr(index*2+1)}
                        ${genWeightedSum_RtExpr_impl <| (index+1i)}
                    }
                } else{
                    !{
                        let ${params->coeffaccess_prefix+toStr(steps)} = ${params->coeff_prefix+toStr(steps)}[(${params->flatten_idxname + "_" + toStr(steps)}:${params->flatten_idxname + "_" + toStr(steps)}+1:1,)]
                        let ${params->inputterm_prefix+toStr(steps+1i)+"_"+toStr(index) + "_" + toStr(unroll)} = ${params->inputterm_prefix+toStr(steps)+"_"+toStr(index*2) + "_" + toStr(unroll)} + 
                                                ${params->coeffaccess_prefix+toStr(steps)} * ${params->inputterm_prefix+toStr(steps)+"_"+toStr(index*2+1) + "_" + toStr(unroll)}
                        ${genWeightedSum_RtExpr_impl <| (index+1i)}
                    }
                }
            } else{
                if(params->quant){
                    // TODO
                    !{
                        let ${params->inputterm_prefix+toStr(steps+1i)+"_"+toStr(index) + "_" + toStr(unroll)} = ${params->inputterm_prefix+toStr(steps)+"_"+toStr(index*2) + "_" + toStr(unroll)} * (1i << ${params->shiftbit}) + 
                                                ${params->coeffaccess_prefix+toStr(steps)} * ${params->inputterm_prefix+toStr(steps)+"_"+toStr(index*2+1) + "_" + toStr(unroll)}
                        ${genWeightedSum_RtExpr_impl <| (index+1i)}
                    }
                } else{
                    !{
                        let ${params->inputterm_prefix+toStr(steps+1i)+"_"+toStr(index) + "_" + toStr(unroll)} = ${params->inputterm_prefix+toStr(steps)+"_"+toStr(index*2) + "_" + toStr(unroll)} + 
                                                ${params->coeffaccess_prefix+toStr(steps)} * ${params->inputterm_prefix+toStr(steps)+"_"+toStr(index*2+1) + "_" + toStr(unroll)}
                        ${genWeightedSum_RtExpr_impl <| (index+1i)}
                    }
                }
            }
        genWeightedSum_RtExpr_impl <| 0i


    let rec genWeightedSum_impl steps unrollindex  =
        if((steps == dims) && (unrollindex == (unroll -1))){
            nextop
        } else if (steps == dims){
            genWeightedSum_RtExpr <| 0 <| (unrollindex + 1) <| (genWeightedSum_impl <| 1 <| (unrollindex + 1i))
        }
         else{
            genWeightedSum_RtExpr <| steps <| unrollindex <| (genWeightedSum_impl <| (steps + 1i) <| unrollindex)
        }
    genWeightedSum_impl <| 0i <| 0i

let genStore dims nums vec unroll params  =
    let spatial_index = bu.get_Spatial_index <| params->spatial_iter <| params
    let rec get_flatten_var index = 
        if(index == (ll.len <| spatial_index)){
            []
        } else{
            !{${params->flatten_idxname + "_" + toStr(index)}} ; (get_flatten_var <| (index+1))
        }
    let flatten_idx_list = get_flatten_var <| 0
    let rec impl unrollindex = 
        if(unrollindex == unroll){
            !{
                _end_
            }
        } else{
            let store_index = if (params->nchw){
                // EXCEPT
                ll.concat <| [!{${params->batch_iter}}] <| (ll.concat <| [!{0i}] <| flatten_idx_list )
            } else{
                ll.concat <| [!{${params->batch_iter}}] <| (ll.concat <| flatten_idx_list <| [!{${params->channel_iter} + ${vec*unrollindex}:(${params->channel_iter}+${vec * (unrollindex+1)}):1}] )
            }
            if (params->quant){
                !{
                    batchoutput[${ll.toRtTuple <| store_index}] <- cast<i8>((${params->inputterm_prefix + toStr(dims) + "_0" + "_" + toStr(unrollindex)}  + (1i << ${dims * params->shiftbit - 1i}))>> (${dims * params->shiftbit}))
                    ${impl <| (unrollindex+1)}
                }
            } else{
                !{
                    batchoutput[${ll.toRtTuple <| store_index}] <- ${params->inputterm_prefix + toStr(dims) + "_0" + "_" + toStr(unrollindex)}
                    ${impl <| (unrollindex+1)}
                }
            }
        }
    impl <| 0
_end_