module core
module common.uniontensor as ut

type Union1DTensor =
| I8Tensor of tensor<i8, 1>
| I32Tensor of tensor<i32, 1>
| F32Tensor of tensor<f32, 1>

let tensorToRTtensor tns =
    match tns with
    | I8Tensor t -> !{${t}}
    | F32Tensor t -> !{${t}}
    | I32Tensor t -> !{${t}}


type Optree<a> =
    | End of a
    | Op of a * Optree<a>
    | Block of a * Optree<a> * Optree<a>

let getop optree = 
    match optree with
    | End(op)                       -> (op, op)
    | Op(op, nextop)                -> (op, nextop)
    | Block(op, innerop, nextop)    -> (op, Op(innerop, nextop))

let getblock optree =
    let (innerops, nextops) = getop optree
    let (innerop, inneropsnew) = getop innerops
    let (nextop, nextopsnew) = getop nextops
    (innerop, inneropsnew, nextop, nextopsnew)

let genRuntimeCode params idxs ops =
    match ops with
    | End(op)                       -> op params idxs ops
    | Op(op, nextop)                -> op params idxs nextop
    | Block(op, innerop, nextop)    -> op params idxs (Op(innerop, nextop))

let rec factorial inputlist =
    match inputlist with
    | []                -> 1i
    | h; t              -> h * factorial <| t

let factorial_tuple inputtuple tuplelen =
    let rec impl index =
        if (index >= tuplelen){
            1i
        } else{
            inputtuple[|index|] * (impl <| (index+1))
        }
    impl <| 0

let rec factorial_num num =
    if (num == 1i){
        num
    } else{
        num * (factorial_num <| (num-1i))
    }

let rec combination n r =
    let denominator = (factorial_num <| r) * (factorial_num <| (n-r))
    (factorial_num <| n ) / denominator

let multf32toi32 multf32 significant_bits =
    let signMask = 0x80000000u32
    let exponentMask = 0x7F800000u32
    let exponentShift = 23u32
    let exponentBias = 127u32
    let fractionMask = 0x007FFFFFu32
    let fractionShift = 7u32
    let fractionOne = 0x00800000u32
    let shiftbuff = 7

    let mut mult = tensor(shapeOf(multf32), 1i32)
    let mut shift = tensor(shapeOf(multf32), 0i32)

    for (i from 0 to shapeOf(multf32)[|0|]){
        let multf32_bits = bitcast<u32>(multf32[(i,)])
        if(significant_bits > 16){
            mult[(i,)] <- cast<i32>(((multf32_bits & fractionMask) | fractionOne) << fractionShift)
            shift[(i,)] <- (1) * ((exponentBias + (31 - 32) - (multf32_bits >> exponentShift)))
        } else{
            mult[(i,)] <- (cast<i32>(((multf32_bits & fractionMask) | fractionOne) << fractionShift) + (1 << (31 - significant_bits))) >> (31 - significant_bits)
            shift[(i,)] <- (1) * ((exponentBias + significant_bits - 1 - (multf32_bits >> exponentShift)))
        }
    }

    (mult, shift)

_end_

