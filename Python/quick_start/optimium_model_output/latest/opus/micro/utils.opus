module core.List.List as ll
module common.uniontensor as ut

let toVectorRangeList vectorstartidxlist vectorsize =
    let rec impl index =
        if(index == (ll.len vectorstartidxlist - 1)){
            let startidx = ll.item index vectorstartidxlist
            [!{${startidx}:${startidx} + ${vectorsize}:1}]
        } else{
            let startidx = ll.item index vectorstartidxlist
            // !{${startidx}:${startidx} + 1:1}; impl (index + 1)
            !{${startidx}}; impl (index + 1)
        }
    impl 0

let toVectorRangeRtTuple vectorstartidxlist vectorsize =
    let tovectorrangelist = toVectorRangeList vectorstartidxlist vectorsize
    ll.toRtTuple tovectorrangelist

let flattenshape shape =
    let mul a b = a * b
    [ll.fold mul 1 shape]

let getvarname prefix index = prefix + "input" + toStr(index)

let baseNotMainSetVars layer_param input_data input_shapes input_zero_points output_shapes output_zero_points input_edges output_edges input_tomains output_tomains input_towhichedges output_towhichedges ismain prefix accumscale = 
    print("baseNotMainSetVars")
    let impl inputnames outputnames inputshapes outputshapes ismutinputs nextop =
        let rec setinputs index nextvar = 
            if(index == (ll.len input_data)){
                nextvar
            } else{
                let data = ll.item index input_data
                let datashape = ll.item index input_shapes
                let folder a b = a * b
                let flattenshape = [ll.fold folder 1 datashape]
                let (layer, edge) = ll.item index input_edges
                let ismaininput = ll.item index input_tomains
                let representative_inputshape = ll.item 0 inputshapes
                let representative_outputshape = ll.item 0 outputshapes
                if((layer == -1) && (ismaininput)){ // set main input
                    let mainedge = ll.item index input_towhichedges
                    let inputname = ll.item mainedge inputnames
                    let inputshape = ll.item mainedge inputshapes
                    let ismut = ll.item mainedge ismutinputs
                    if(ismut){
                        !{
                            let mut ${inputname} = reshapeTo(${ll.toRtTuple inputshape}, &inputs[|${edge}|])
                            ${setinputs (index + 1) nextvar}
                        }
                    } else{
                        !{
                            let ${inputname} = reshapeTo(${ll.toRtTuple inputshape}, inputs[|${edge}|])
                            ${setinputs (index + 1) nextvar}
                        }
                    }
                } else if((layer == -1)){ // set micro input
                    let varname = getvarname prefix index
                    let dataexpr x = 
                        if((ll.len representative_inputshape) == 1){ // flatten
                            let varshape = ll.toRtTuple(flattenshape)
                            !{reshapeTo(${varshape}, ${x})}
                        } else{
                            let varshape = ll.toRtTuple(representative_outputshape) // will be problem
                            !{reshapeTo(${varshape}, ${x})}
                        }
                    let vardata = dataexpr (!{&inputs[|${edge}|]})
                    !{
                        let mut ${varname} = ${vardata}
                        ${setinputs (index + 1) nextvar}
                    }
                } else if(!(ut.isEmpty data)){ // set micro constant
                    let varname = getvarname prefix index 
                    let dataexpr x = 
                        if(ll.len representative_inputshape == 0){
                            !{${x}}
                        } else{
                            let varshape = ll.toRtTuple(shape)
                            !{reshapeTo(${varshape}, ${x})}
                        }
                    let vardata = 
                        match data with
                            | ut.TensorI8 x    -> dataexpr x
                            | ut.TensorF16 x   -> dataexpr x
                            | ut.TensorF32 x   -> dataexpr x
                    !{
                        let ${varname} = ${vardata}
                        ${setinputs (index + 1) nextvar}
                    }
                } else{
                    setinputs (index + 1) nextvar
                }
            }
        let setoutputs nextvar = (
            let (layer, edge) = ll.item 0 output_edges
            let ismainoutput  = ll.item 0 output_tomains
            if((layer == -1) && (ismainoutput)){
                let mainedge = ll.item 0 output_towhichedges
                let outputname = ll.item mainedge outputnames
                let outputshape = ll.item mainedge outputshapes
                !{
                    let mut ${outputname} = reshapeTo(${ll.toRtTuple outputshape}, &outputs[|${edge}|])
                    ${nextvar}
                }
            } else{
                nextvar
            }
        )
        // quantization will be supported
        // let setmultshift nextop =
        setinputs 0 (setoutputs nextop)
    impl

let basePadOps layer_param input_shapes output_shapes = 
    let output_shape = ll.item 0 output_shapes
    let impl preopflag prepadding =
        let padding =
            let rec impl index = 
                if(index == ll.len output_shape){
                    []
                } else{
                    let prepadl = ll.item 0 (ll.item index prepadding)
                    let prepadr = ll.item 1 (ll.item index prepadding)
                    [prepadl + 0; prepadr + 0]; impl (index + 1)
                }
            impl 0
        (padding, output_shape)
    impl

let baseBinaryOpSetVars layer_param input_data input_shapes input_zero_points output_shapes output_zero_points input_edges output_edges input_tomains output_tomains input_towhichedges output_towhichedges ismain prefix accumscale = 
    let impl inputnames outputnames inputshapes outputshapes ismutinputs nextop =
        let rec setinputs index nextvar = 
            if(index == (ll.len input_data)){
                nextvar
            } else{
                let data = ll.item index input_data
                let datashape = ll.item index input_shapes
                let folder a b = a * b
                let flattenshape = [ll.fold folder 1 datashape]
                let (layer, edge) = ll.item index input_edges
                let ismaininput = ll.item index input_tomains
                let representative_inputshape = ll.item 0 inputshapes
                let representative_outputshape = ll.item 0 outputshapes
                if((layer == -1) && (ismaininput) && (ut.isEmpty data)){ // set main input
                    let mainedge = ll.item index input_towhichedges
                    let inputname = ll.item mainedge inputnames
                    let inputshape = ll.item mainedge inputshapes
                    let ismut = ll.item mainedge ismutinputs
                    if(ismut){
                        !{
                            let mut ${inputname} = reshapeTo(${ll.toRtTuple inputshape}, &inputs[|${edge}|])
                            ${setinputs (index + 1) nextvar}
                        }
                    } else{
                        !{
                            let ${inputname} = reshapeTo(${ll.toRtTuple inputshape}, inputs[|${edge}|])
                            ${setinputs (index + 1) nextvar}
                        }
                    }
                } else if(!(ut.isEmpty data)){ // set micro constant
                    let varname = 
                        if(ismain){
                            ll.item index inputnames
                        } else{
                            getvarname prefix index 
                        }
                    let dataexpr x = 
                        if(ismain){
                            let varshape = ll.toRtTuple(ll.item index inputshapes)
                            !{reshapeTo(${varshape}, ${x})}
                        } else{
                            if(ll.len (ll.item index input_shapes) == 1){
                                let varshape = (
                                    let rec impl index =
                                        if(index == ll.len representative_inputshape){
                                            []
                                        } else{
                                            1; impl (index + 1)
                                        }
                                    ll.toRtTuple(impl 0)
                                )
                                !{reshapeTo(${varshape}, ${x})}
                            }else if(ll.len representative_inputshape == 1){ // flatten
                                let varshape = ll.toRtTuple(flattenshape)
                                !{reshapeTo(${varshape}, ${x})}
                            } else{
                                let varshape = ll.toRtTuple(ll.item index inputshapes)
                                !{reshapeTo(${varshape}, ${x})}
                            }
                        }
                    let vardata = 
                        match data with
                            | ut.TensorI8 x    -> dataexpr x
                            | ut.TensorF16 x   -> dataexpr x
                            | ut.TensorF32 x   -> dataexpr x
                    !{
                        let ${varname} = ${vardata}
                        ${setinputs (index + 1) nextvar}
                    }
                } else if((layer == -1)){ // set micro input
                    let varname = getvarname prefix index
                    let dataexpr x = 
                        if((ll.len representative_inputshape) == 1){ // flatten
                            let varshape = ll.toRtTuple(flattenshape)
                            !{reshapeTo(${varshape}, ${x})}
                        } else{
                            let varshape = ll.toRtTuple(representative_outputshape) // will be problem
                            !{reshapeTo(${varshape}, ${x})}
                        }
                    let vardata = dataexpr (!{&inputs[|${edge}|]})
                    !{
                        let mut ${varname} = ${vardata}
                        ${setinputs (index + 1) nextvar}
                    }
                } else{
                    setinputs (index + 1) nextvar
                }
            }
        let setoutputs nextvar = (
            let (layer, edge) = ll.item 0 output_edges
            let ismainoutput  = ll.item 0 output_tomains
            if((layer == -1) && (ismainoutput)){
                let mainedge = ll.item 0 output_towhichedges
                let outputname = ll.item mainedge outputnames
                let outputshape = ll.item mainedge outputshapes
                !{
                    let mut ${outputname} = reshapeTo(${ll.toRtTuple outputshape}, &outputs[|${edge}|])
                    ${nextvar}
                }
            } else{
                nextvar
            }
        )
        // quantization will be supported
        // let setmultshift nextop =
        setinputs 0 (setoutputs nextop)
    impl

_end_