module core.List.List as ll
module common.uniontensor as ut
module common.params as params
module common.layerparams as lparams
module micro.microimpl as mi
module micro.graphutils as gu

// (isMain, passScale, setVars, loopOps, microOps, storeOps)
// isMain: 
//      if layer is main layer : true, else : false
// passScale: 
//      (passed_scale, significant_bits, fusibility)
//      passed_scale(list<tensor<1, f32>>): accumulated scale
//      significant_bis(i32): required bits for the operation without precision loss
//      fusibility(bolean): possibility of fusion in the next layer
// setVars:
//      setting variables for the micro layer
//      let setvars nextop =
//          !{
//              let var1 = ...
//              !{nextop}
//          }
//      [setvars]
// loopOps:
//      loop scale operations
//      let loopop nextop =
//          !{
//              for(some loop here){
//                  (some operation needs seperate loop)
//              }
//              ${nextop}
//          } 
//      [loopop]
// microOps:
//      micro sccale(vectorwise) oprations
//      let microop inputvectorname outputvectorname multshift significant_bits nextop =
//          !{
//              (some vectorwise operation)
//              ${nextop}
//          }
//      [microop]
// storeOps:
//      index mapping for the stroing operation
//      let storeop sourceidx vectorsize =
//          !{(destidx:destidx + vecotsize:1,)}
//      [storeop]

let getMicroImplList layer_params =
    // get micro implementations from list of layer_param
    let rec impl index =
        if(index == (ll.len layer_params)){
            ([], [], [], [], [], [], [])
        } else{
            let layer_param = ll.item index layer_params
            let (isMain, passScale, setVars, loopOps, microOps, storeOps, padOps) = mi.getMicroImpl layer_param
            let (isMain2, passScale2, setVars2, loopOps2, microOps2, storeOps2, padOps2) = impl (index + 1)
            (isMain; isMain2, passScale; passScale2, setVars; setVars2, loopOps; loopOps2, microOps; microOps2, storeOps; storeOps2, padOps; padOps2)
        }
    impl 0

let isSingleMainLayer ismainlist =
    // check if there is only one main layer
    let mut num = 0
    for(i from 0 to (ll.len ismainlist)){
        let ismain = ll.item i ismainlist
        if(ismain){
            num <- num + 1
        } else{
            _end_
        }
    }
    if(num == 1 || (ll.len ismainlist == 1)){
        true
    } else{
        except("There are too many fusible main layers(" + toStr(num) + ")")
    }

let isValidEdges layer_params input_edges output_edges =
    let numlayers = ll.len layer_params
    for(i from 0 to numlayers){
        let thislayer = ll.item i layer_params
        let thisinputedge = ll.item i input_edges
        let thisoutputedge = ll.item i output_edges

        let _ = if((ll.len thisoutputedge) > 1){
            except("Only single output layer is supported. There are multiple output in " + thislayer)
        } else{
            0
        }

        let (outputlayer, outputedge) = ll.item 0 thisoutputedge
        let _ = if((outputlayer < 0) && (i < numlayers - 1)){
            except("Only the last layer can have runtime output edge. There is runtime output edge in " + toStr(thislayer))
        } else if((outputlayer > 0) && (i >= outputlayer)){
            except("Fused output edge should be an input edge in the later layer. This layer is (" + toStr(thislayer) + ") and fused layer is (" + toStr(ll.item outputlayer layer_params) + ")")
        } else if(i == numlayers -1 && outputlayer >= 0){
            except("Last layer shold have runtime output, but has fused edge to (" + toStr(ll.item outputlayer layer_params) + ")")
        } else{
            0
        }

        for(j from 0 to (ll.len thisinputedge)){
            let (inputlayer, inputedge) = ll.item j thisinputedge
            let _ = if((inputlayer > 0) && (i <= inputlayer )){
                except("Fused input edge should be an output edge in the previous layer. This layer is (" + toStr(thislayer) + ") and fused layer is (" + toStr(ll.item inputlayer layer_params) + ")")
            } else{
                0
            }
        }
    }
    true

let validityChecker layer_params input_edges output_edges ismainlist = 
    let check_single_main = isSingleMainLayer ismainlist
    let check_edges = isValidEdges layer_params input_edges output_edges
    if(check_single_main && check_edges){
        true
    } else{
        false
    }

let quantChecker input_scales output_scales = 
    let mut num_quant_input = 0
    for(layer from 0 to (ll.len input_scales)){
        let l1 = ll.item layer input_scales
        for(input from 0 to (ll.len l1)){
            let i1 = ll.item input l1
            if(ut.isEmpty i1){
                _end_
            } else{
                num_quant_input <- num_quant_input + 1
            }
        }
    }
    let mut num_quant_output = 0
    for(layer from 0 to (ll.len output_scales)){
        let l1 = ll.item layer output_scales
        for(input from 0 to (ll.len l1)){
            let i1 = ll.item input l1
            if(ut.isEmpty i1){
                _end_
            } else{
                num_quant_output <- num_quant_output + 1
            }
        }
    }
    if(num_quant_input > 0 || num_quant_output > 0){true} else{false}

let splitPreAndPostOps ismainlist microopslist flag =
    // split micro ops to premicroops and postmicroops based on main layer
    let rec impl index preopflag = 
        if(index == (ll.len ismainlist)){
            ([], [])
        } else{
            let ismain = ll.item index ismainlist
            let op = ll.item index microopslist
            if(ismain){
                let (preops, postops) = impl (index + 1) false
                (preops, postops)
            } else if(preopflag){
                let (preops, postops) = impl (index + 1) preopflag
                if(flag){
                    (op preopflag; preops, postops)
                } else{
                    (op ; preops, postops)
                }
            } else{
                let (preops, postops) = impl (index + 1) preopflag
                if(flag){
                    (preops, op preopflag; postops)
                } else{
                    (preops, op; postops)
                }
            }
        }
    if(ll.len(ismainlist) == 1){
        ([], [])
    } else{
        impl 0 true
    }

let squeezedouplelist list =
    // squeeze the List<List<>> type ops for the later use
    let impl index =
        if(index == (ll.len list)){
            []
        } else{
            let thislist = ll.item index list
            let nextlist = impl (index + 1)
            if((ll.len thislist) == 0){
                nextlist
            } else{
                (ll.item 0 thislist); nextlist
            }
        }
    impl 0

let accumulateScales layer_params input_scales output_scales input_edges output_edges passScaleList isQuant = 
    // accumulate scales
    // We only consider topological sorted single branch graph right now
    if(isQuant){
        // for(i from 0 to (ll.len layer_params)){
        //     let passscale = ll.item i passScaleList
        //     let input_scale = ll.item i input_scales
        //     let output_scale = ll.item i output_scales
        //     let input_edge = ll.item i input_edges
        //     let output_edge = ll.item i output_edges
        //     for(e from 0 to (ll.len input_edges)){
        //         let (layer, edge) = ll.item e input_edge
        //         if(layer > 0){
        //             let pre = ll.take e input_scales
        //             let post = ll.reverse (ll.take ((ll.len input_scales) - (e + 1)) (ll.reverse input_scales))
        //         } else{
        //             _end_
        //         }
        //     }
        //     let (scalelist, bits, fusibility) = passscale input_scale output_scale
        //     out = if(fusibility && ((ll.len scalelist) == 1)){
        //         (ll.item scalelist, bits)
        //     } else{
        //         except("This layer is not fusible in this sequence. " + toStr(ll.item index layer_params))
        //     }
        // }
        ([], 32)
    } else{
        ([], 32)
    }

let genPrefix index = "fused" + toStr(index) + "_"

let prepareSetVars layer_params input_data input_shapes input_zero_points output_shapes output_zero_points input_edges output_edges input_tomains output_tomains input_towhichedges output_towhichedges accumscale ismainlist setvarslist = 
    let rec feedargs index =
        if(index == (ll.len setvarslist)){
            []
        } else{
            let setvars = ll.item index setvarslist
            let thislayer_param = ll.item index layer_params
            let thisinput_data = ll.item index input_data
            let thisinput_shapes = ll.item index input_shapes
            let thisinput_zero_points = ll.item index input_zero_points
            let thisoutput_shapes = ll.item index output_shapes
            let thisoutput_zero_points = ll.item index output_zero_points
            let thisinput_edges = ll.item index input_edges
            let thisoutput_edges = ll.item index output_edges
            let thisinput_tomains = ll.item index input_tomains
            let thisoutput_tomains = ll.item index output_tomains
            let thisinput_towhichedges = ll.item index input_towhichedges
            let thisoutput_towhichedges = ll.item index output_towhichedges
            let thisismain = ll.item index ismainlist
            let thisprefix = genPrefix index
            let thisaccumscale = accumscale
            let fed = setvars thislayer_param thisinput_data thisinput_shapes thisinput_zero_points thisoutput_shapes thisoutput_zero_points thisinput_edges thisoutput_edges thisinput_tomains thisoutput_tomains thisinput_towhichedges thisoutput_towhichedges thisismain thisprefix thisaccumscale
            fed; (feedargs (index + 1))
        }
    feedargs 0

let genSetVarsExpr setvarsimpls inputnames outputnames inputshapes outputshapes ismutinputs nextop =
    let rec impl index =
        if(index == (ll.len setvarsimpls)){
            nextop
        } else{
            let setvars = ll.item index setvarsimpls
            setvars inputnames outputnames inputshapes outputshapes ismutinputs (impl (index + 1))
        }
    impl 0

let prepareMicroOps layer_params input_data input_shapes input_edges output_edges input_tomains output_tomains ismainlist microOpsList =
    let rec feedargs index =
        if(index == (ll.len microOpsList)){
            []
        } else{
            let microop = ll.item index microOpsList
            let thislayer_param = ll.item index layer_params
            let thisinput_data = ll.item index input_data
            let thisinput_shapes = ll.item index input_shapes
            let thisinput_edges = ll.item index input_edges
            let thisoutput_edges = ll.item index output_edges
            let thisinput_tomains = ll.item index input_tomains
            let thisoutput_tomains = ll.item index output_tomains
            let thisismain = ll.item index ismainlist
            let thisprefix = genPrefix index
            let fed = microop thislayer_param thisinput_data thisinput_shapes thisinput_edges thisoutput_edges thisinput_tomains thisoutput_tomains thisismain thisprefix
            fed; (feedargs (index + 1))
        }
    feedargs 0

let genMicroOpsExpr microopsimpls inputvectorname outputvectorname vectorstartidxlist vectorsize vectordtype nextop =
    let rec impl index =
        if(index == (ll.len microopsimpls)){
            nextop
        } else{
            if(inputvectorname == outputvectorname){ // inplace
                let setvars = ll.item index microopsimpls
                setvars inputvectorname outputvectorname vectorstartidxlist vectorsize vectordtype (impl (index + 1))
            } else{
                // not implemented
                let setvars = ll.item index microopsimpls
                setvars inputvectorname outputvectorname vectorstartidxlist vectorsize vectordtype (impl (index + 1))
            }
        }
    impl 0

let prepareMapIdxCtOps layer_params input_shapes output_shapes mapIdxCtOpsList=
    let rec feedargs index =
        if(index == (ll.len mapIdxCtOpsList)){
            []
        } else{
            let mapidxctop = ll.item index mapIdxCtOpsList
            let thislayer_param = ll.item index layer_params
            let thisinput_shape = ll.item index input_shapes
            let thisoutput_shape = ll.item index output_shapes
            let fed = mapidxctop thislayer_param thisinput_shape thisoutput_shape
            fed; feedargs (index + 1)
        }
    feedargs 0

let mapIdxCtOpsList mapidxctimpls idxlist isflatten =
    let rec impl index idxlist =
        if(index == (ll.len mapidxctimpls - 1)){
            let thisop = ll.item index mapidxctimpls
            let idxlist_new = thisop idxlist isflatten
            idxlist_new
        } else{
            let thisop = ll.item index mapidxctimpls
            let idxlist_new = thisop idxlist isflatten
            impl (index + 1) idxlist_new
        }
    impl 0 idxlist

let preparePadOps layer_params input_shapes output_shapes padOpsList = 
    let rec feedargs index =
        if(index == (ll.len padOpsList)){
            []
        } else{
            let padop = ll.item index padOpsList
            let thislayer_param = ll.item index layer_params
            let thisinput_shape = ll.item index input_shapes
            let thisoutput_shape = ll.item index output_shapes
            let fed = padop thislayer_param thisinput_shape thisoutput_shape
            fed; feedargs (index + 1)
        }
    feedargs 0

let padOps padopslist prepadding shape =
    if((ll.len padopslist) == 0){
        (prepadding, shape)
    } else{
        let rec impl index prepadding =
            let padop = ll.item index padopslist
            let (newpadding, newshape) = padop prepadding
            if(index == (ll.len padopslist - 1)){
                (newpadding, newshape)
            } else{
                impl (index + 1) newpadding
            }
        impl 0 prepadding
    }

let prepareLoopOps layer_params input_shapes input_dtypes input_zero_points output_shapes output_dtypes output_zero_points output_towhichedges loopOpsList = 
    let rec feedargs index =
        if(index == (ll.len loopOpsList)){
            []
        } else{
            let loopop = ll.item index loopOpsList
            let thislayer_param = ll.item index layer_params
            let thisinput_shape = ll.item index input_shapes
            let thisinput_dtype = ll.item index input_dtypes
            let thisinput_zero_points = ll.item index input_zero_points
            let thisoutput_shape = ll.item index output_shapes
            let thisoutput_dtype = ll.item index output_dtypes
            let thisoutput_zero_points = ll.item index output_zero_points
            let thisoutput_towhichedges = ll.item index output_towhichedges
            let thisprefix = genPrefix index
            let fed = loopop thislayer_param thisinput_shape thisinput_dtype thisinput_zero_points thisoutput_shape thisoutput_dtype thisoutput_zero_points thisoutput_towhichedges thisprefix
            fed; feedargs (index + 1)
        }
    feedargs 0

let genLoopOpsExpr loopopsimpls outputnames nextop =
    let rec impl index =
        if(index == (ll.len loopopsimpls)){
            nextop
        } else{
            let loopop = ll.item index loopopsimpls
            loopop outputnames (impl (index + 1))
        }
    impl 0


let init layer_params input_data input_dtypes input_shapes input_scales input_zero_points output_dtypes output_shapes output_scales output_zero_points input_edges output_edges ismainops =
    let (isMainList, passScaleList, setVarsList, loopOpsList, microOpsList, storeOpsList, padOpsList) = getMicroImplList layer_params

    let _ = validityChecker layer_params input_edges output_edges ismainops
    let isQuant = quantChecker input_scales output_scales
    let (accumscale, bits) = accumulateScales layer_params input_scales output_scales input_edges output_edges passScaleList isQuant
    let (input_tomains, output_tomains) = gu.toMainEdgeList input_edges output_edges ismainops
    let (input_towhichedges, output_towhichedges) = gu.toWhichMainEdgeList input_edges output_edges input_tomains output_tomains ismainops

    let setVarsImpls = prepareSetVars layer_params input_data input_shapes input_zero_points output_shapes output_zero_points input_edges output_edges input_tomains output_tomains input_towhichedges output_towhichedges accumscale ismainops setVarsList
    let microOpsImpls = prepareMicroOps layer_params input_data input_shapes input_edges output_edges input_tomains output_tomains ismainops microOpsList
    let (preMicroOpsImpls, postMicroOpsImpls) = splitPreAndPostOps ismainops microOpsImpls false
    // let mapIdxCtOpsImpls = prepareMapIdxCtOps layer_params input_shapes output_shapes mapIdxCtOpsList
    let padOpsImpls = preparePadOps layer_params input_shapes output_shapes padOpsList
    let (inputPadOpsImpls, outputPadOpsImpls) = splitPreAndPostOps ismainops padOpsImpls true
    let loopOpsImpls = prepareLoopOps layer_params input_shapes input_dtypes input_zero_points output_shapes output_dtypes output_zero_points output_towhichedges loopOpsList

    (setVarsImpls, preMicroOpsImpls, postMicroOpsImpls, inputPadOpsImpls, outputPadOpsImpls, loopOpsImpls)

_end_
