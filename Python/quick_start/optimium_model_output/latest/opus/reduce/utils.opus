module core.List.List as ll
module common.uniontensor as ut

type AxisUnion =
	| Axes of ll.List<i32>
	| Axis of i32

type Optional<a> = 
    | Value of a
    | None

let rec createIncList lst n =
    match n with
    | 0 -> 0 ; lst
    | _ -> 
        let tempList = createIncList lst (n-1)
        n;tempList

let rec createRtIncList lst n =
    let list = match n with
                | 0 -> !{0} ; lst
                | _ -> 
                    let tempList = createIncList lst (n-1)
                    n;tempList
    ll.reverse <| list

let rec get_flattend_len shape_list = 
    match shape_list with
    | []   -> 1i
    | h;t  -> h* get_flattend_len t

let get_list_slice begin_idx end_idx input_list =
    let rec _get_list_slice lst cur_idx = 
        if (cur_idx >= end_idx) {
            []
        } else {
            (ll.item <| cur_idx <| input_list) ; (_get_list_slice <| lst <| (cur_idx+1))
        }
    _get_list_slice <| [] <| begin_idx

let extract_elems_by_indices indices input_list =
    let num_indices = ll.len <| indices
    let rec extract_elems lst idx_idx = 
        if (idx_idx == (num_indices-1)) {
            ll.item <| (ll.item <| idx_idx <| indices) <| input_list ; []
        } else {
            ll.item <| (ll.item <| idx_idx <| indices) <| input_list ; (extract_elems <| lst <| (idx_idx+1))
        }
    extract_elems <| [] <| 0

// TO CHANGE NAME
let get_input_indices_jy num axes keepdims parallel_itername reduction_itername =
    let rec get_indices cur_idx cur_red cur_not_red =
        if (cur_idx == num) {
            []
        } else {
            if (cur_idx == (ll.item <| cur_red <| axes)) {
                !{${reduction_itername + toStr(cur_red)}} ; (get_indices <| (cur_idx + 1) <| (cur_red + 1) <| cur_not_red)
            } else {
                if (keepdims) {
                    !{${(parallel_itername + toStr(cur_idx))}} ; (get_indices <| (cur_idx + 1) <| cur_red <| (cur_not_red + 1))
                } else {
                    !{${(parallel_itername + toStr(cur_not_red))}} ; (get_indices <| (cur_idx + 1) <| cur_red <| (cur_not_red + 1))
                }
            }
        }
    get_indices 0 0 0

// TO BE DEPRECATED WHEN PORTING IS ALL DONE
let get_input_indices input_shape axes pack keepdims =
    let input_shape_len = ll.len <| input_shape
    let rec get_indices cur_idx cur_red cur_not_red =
        if (cur_idx == input_shape_len) {
            [!{p}; !{0:${pack}:1}]
        } else {
            if (cur_idx == (ll.item <| cur_red <| axes)) {
                !{${("r_idx" + toStr(cur_red))}} ; (get_indices <| (cur_idx + 1) <| (cur_red + 1) <| cur_not_red)
            } else {
                if (keepdims) {
                    !{${("idx" + toStr(cur_idx))}} ; (get_indices <| (cur_idx + 1) <| cur_red <| (cur_not_red + 1))
                } else {
                    !{${("idx" + toStr(cur_not_red))}} ; (get_indices <| (cur_idx + 1) <| cur_red <| (cur_not_red + 1))
                }
            }
        }
    get_indices 0 0 0
// TO BE DEPRECATED
let get_input_indices_no_pack input_shape axes keepdims=
    let input_shape_len = ll.len <| input_shape
    let axes_len = ll.len <| axes
    let rec get_indices cur_idx cur_red cur_not_red =
        if (cur_idx == input_shape_len) {
            []
        } else {
            if (cur_idx == (ll.item <| cur_red <| axes)) {
                !{${("r_idx" + toStr(cur_red))}} ; (get_indices <| (cur_idx + 1) <| (cur_red + 1) <| cur_not_red)
            } else {
                if (keepdims) {
                    !{${("idx" + toStr(cur_idx))}} ; (get_indices <| (cur_idx + 1) <| cur_red <| (cur_not_red + 1))
                } else {
                    !{${("idx" + toStr(cur_not_red))}} ; (get_indices <| (cur_idx + 1) <| cur_red <| (cur_not_red + 1))
                }
            }
        }
    get_indices 0 0 0

// TO CHANGE ITS NAME
let get_output_access_jy num axes keepdims parallel_itername =
    let rec get_access cur_idx cur_red cur_not_red =
        if (cur_idx == num) {
            []
        } else {
            if (cur_idx == (ll.item <| cur_red <| axes)) {
                if (keepdims) {
                    !{0} ; get_access <| (cur_idx + 1) <| (cur_red + 1) <| cur_not_red
                } else {
                    get_access <| (cur_idx + 1) <| (cur_red + 1) <| cur_not_red
                }
            } else {
                if (keepdims) {
                    !{${parallel_itername + toStr(cur_idx)}} ; get_access <| (cur_idx + 1) <| (cur_red) <| (cur_not_red + 1)
                } else {
                    !{${parallel_itername + toStr(cur_not_red)}} ; get_access <| (cur_idx + 1) <| (cur_red) <| (cur_not_red + 1)
                }
            }
        }
    get_access 0 0 0

// TO BE DEPRECATED
let get_output_access input_shape axes keepdims pack =
    let input_shape_len = ll.len <| input_shape
    let rec get_access cur_idx cur_red cur_not_red =
        if (cur_idx == input_shape_len) {
            [!{p}; !{0:${pack}:1}]
        } else {
            if (cur_idx == (ll.item <| cur_red <| axes)) {
                if (keepdims) {
                    !{0} ; get_access <| (cur_idx + 1) <| (cur_red + 1) <| cur_not_red
                } else {
                    get_access <| (cur_idx + 1) <| (cur_red + 1) <| cur_not_red
                }
            } else {
                if (keepdims) {
                    !{${"idx" + toStr(cur_idx)}} ; get_access <| (cur_idx + 1) <| (cur_red) <| (cur_not_red + 1)
                } else {
                    !{${"idx" + toStr(cur_not_red)}} ; get_access <| (cur_idx + 1) <| (cur_red) <| (cur_not_red + 1)
                }
            }
        }
    get_access 0 0 0

// TO BE DEPRECATED
let get_output_access_no_pack input_shape axes keepdims =
    let input_shape_len = ll.len <| input_shape
    let axes_len = ll.len <| axes
    let rec get_access cur_idx cur_red cur_not_red =
        if (cur_idx == input_shape_len) {
            []
        } else {
            if (cur_idx == (ll.item <| cur_red <| axes)) {
                if (keepdims) {
                    !{0} ; get_access <| (cur_idx + 1) <| (cur_red + 1) <| cur_not_red
                } else {
                    get_access <| (cur_idx + 1) <| (cur_red + 1) <| cur_not_red
                }
            } else {
                if (keepdims) {
                    !{${"idx" + toStr(cur_idx)}} ; get_access <| (cur_idx + 1) <| (cur_red) <| (cur_not_red + 1)
                } else {
                    !{${"idx" + toStr(cur_not_red)}} ; get_access <| (cur_idx + 1) <| (cur_red) <| (cur_not_red + 1)
                }
            }
        }
    get_access 0 0 0

let get_ravel_index input_shape index_list =
    let dim_len = ll.len <| input_shape
    let index_list_len = ll.len <| index_list
    let _ = if (dim_len != index_list_len) {
        except("input_shape and index_list must have the same dimension")
    } else {
        _end_
    }
    let rec ravel_index dim_idx cum_idx =
        if (dim_idx == (dim_len - 1)) {
            cum_idx + (ll.item <| dim_idx <| index_list)
        } else {
            if ((ll.item <| dim_idx <| input_shape) == 1) {
                ravel_index <| (dim_idx + 1) <| (cum_idx)    
            } else {
                let mut offset = (ll.item <| dim_idx <| index_list)
                for (remaining_idx from (dim_idx + 1) to dim_len) {
                    offset <- (offset * (ll.item <| remaining_idx <| input_shape))
                    _end_    
                }
                ravel_index <| (dim_idx + 1) <| (cum_idx + offset)
            }
        }
    ravel_index <| 0 <| 0

let get_unravel_index input_shape raveled_index =
    let dim_len = ll.len <| input_shape
    let rec get_input_size shape_list = 
        match shape_list with
        | []   -> 1i
        | h;t  -> h* get_input_size t
    let input_size = get_input_size input_shape
    let _ = if (input_size <= raveled_index) {
        except("ouf of bounds: raveled index exceeds the size of input")
    } else {
        _end_
    }

    let last_dim_idx = (dim_len - 1)
    let rec unravel_index index_list dim_idx div mod =
        let new_div = 
            if (dim_idx == last_dim_idx) {
                div
            } else {
                (div - mod) / (ll.item <| (dim_idx+1) <| input_shape)
            }
        let new_mod = new_div % (ll.item <| dim_idx <| input_shape)
        if (dim_idx == 0) {
            new_mod ; index_list
        } else {
            new_mod; (unravel_index <| index_list <| (dim_idx - 1) <| new_div <| new_mod)
        }
    ll.reverse <| (unravel_index <| [] <| last_dim_idx <| raveled_index <| 0)

let index_uniontensor index_tuple uniontensor = 
    match uniontensor with
        | ut.TensorI8 t    -> t[index_tuple]
        | ut.TensorI16 t   -> t[index_tuple]
        | ut.TensorI32 t   -> t[index_tuple]
        | ut.TensorI64 t   -> t[index_tuple]
        | ut.TensorF16 t   -> t[index_tuple]
        | ut.TensorF32 t   -> t[index_tuple]
        | ut.EMPTY         -> except("EMPTY tensor cannot be converted to runtime expression")

type TemplateParameters = {
    input_t : rtType, input_dtypes : rtType, input_shapes : tuple<i32, i32, i32, i32>, input_scales : ll.List<ll.List<ut.UnionTensor>>, input_zero_points : ll.List<ll.List<ut.UnionTensor>>,
    output_t : rtType, output_dtypes : rtType, output_shapes : tuple<i32, i32, i32, i32>, output_scales : ll.List<ll.List<ut.UnionTensor>>, output_zero_points : ll.List<ll.List<ut.UnionTensor>>,
    pack : i32, axis : ll.List<i32>, keepdim : bool
}

type CodeGenParameters = {
    is_quant : bool, pack : i32, axes : ll.List<i32>, keepdim : bool, num_axes : i32, last_consec_parallel_axis : i32,
    reduction_itername : string, parallel_itername : string, last_parallel_itername : string, reduction_vecname : string, 
    batch_input_name : string , batch_output_name : string, reshaped_input_name : string, reshaped_output_name : string,
    input_iters: ll.List<rtExpr>, // TODO - replace rtType by rtExpr type
    output_access : ll.List<rtExpr>, last_parallel_size : i32, reduce_indices: ll.List<i32>, outer_indices : ll.List<i32>,
    input_scale : ut.UnionTensor, input_zero_point : ut.UnionTensor,  output_scale : ut.UnionTensor, output_zero_point : ut.UnionTensor,
}

let initCodeGen params = 
    let input_dtype = ll.item 0 (ll.item 0 (params->input_dtypes))
    let input_shape = ll.item 0 (ll.item 0 (params->input_shapes))
    let input_scale = ll.item 0 (ll.item 0 (params->input_scales))
    let input_zero_point = ll.item 0 (ll.item 0 (params->input_zero_points))
    let output_shape = ll.item 0 (ll.item 0 (params->output_shapes))
    let output_scale = ll.item 0 (ll.item 0 (params->output_scales))
    let output_zero_point = ll.item 0 (ll.item 0 (params->output_zero_points))
    let is_quant = (input_dtype == rtType(i8))
    let axes = 
        if ((ll.item <| 0 <| params->axis) == -1) {
            ll.reverse <| (u.createIncList <| [] <| (input_dim - 1))
        } else {
            params->axis
        }
    let num_axes = ll.len <| axes
    let max_reduction_axis = ll.item <| (num_axes - 1) <| axes
    let input_dim = ll.len <| input_shape
    let last_consec_parallel_axis = 
            if (max_reduction_axis == (input_dim - 1)) {
                -1
            } else {
                max_reduction_axis + 1
            }
    let last_consec_parallel_num = 
        if(last_consec_parallel_axis >= 0){
            (ll.len <| input_shape) - last_consec_parallel_axis
        } else{
            0
        }
        
    
    let last_parallel_size = 
        let folder s e = s * e
        let parallel_shapes = get_list_slice <| ((ll.len <| output_shape) - last_consec_parallel_num) <| (ll.len <| output_shape) <| output_shape
        if ((ll.len <| parallel_shapes) == 0){
            0
        } else{
            ll.fold folder 1 parallel_shapes
        }

    let reduce_indices = extract_elems_by_indices <| axes <| input_shape
    let outer_indices = get_list_slice <| 0 <| ((ll.len <| output_shape) - last_consec_parallel_num) <| output_shape

    let parallel_itername = "p_idx"
    let reduction_itername = "r_idx"
    let reduction_vecname = "redvec"
    let batch_output_name = "batchoutput"
    let batch_input_name = "batchinput"
    let reshaped_input_name = "input_reshaped"
    let reshaped_output_name = "output_reshaped"

    let (input_iters, output_access) = if (last_consec_parallel_axis >= 0){
        let _input_iters = get_input_indices_jy <| last_consec_parallel_axis <| axes <| params->keepdim <| parallel_itername <| reduction_itername
        let _output_access = get_output_access_jy <| last_consec_parallel_axis <| axes <| params->keepdim <| parallel_itername
        (_input_iters, _output_access)
    } else{
        let _input_iters = get_input_indices_jy <| (ll.len <| output_shape) <| axes <| params->keepdim <| parallel_itername <| reduction_itername
        let _output_access = get_output_access_jy <| (ll.len <| output_shape) <| axes <| params->keepdim <| parallel_itername
        (_input_iters, _output_access)
    }
    


    let codeGenParameters = CodeGenParameters(is_quant, params->pack, axes, params->keepdim, num_axes, last_consec_parallel_axis, 
                                            reduction_itername, parallel_itername, "p", reduction_vecname, batch_input_name, batch_output_name, reshaped_input_name, reshaped_output_name,
                                            input_iters, output_access, last_parallel_size, reduce_indices, outer_indices,
                                            input_scale, input_zero_point, output_scale, output_zero_point)
    codeGenParameters


_end_