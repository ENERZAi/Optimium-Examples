module core.List.List as ll
module common.uniontensor as ut

let get_tile_for_one_dim elnum pack =
    let start1 = 0
    let end2 = elnum
    let end1 = elnum - (elnum % pack)
    let start2 = end1
    ((start1, end1), (start2, end2))

let get_quant_ct_vec is_quant sz val= 
    if (is_quant) {
        ut.TensorI32(tensor((sz,), val))
    } else {
        ut.TensorF32(tensor((sz,), 0.f32))
    }

// CAUTION - assume input/output tensor is quantized by tensor-wise scheme
let get_quant_ct_complex_vec is_quant sz =
    let scale_val =
        if (params->is_quant) {
            ((ut.toCtTensorF32 <| params->input_scale) / (ut.toCtTensorF32 <| params->output_scale))[(0,)]
        } else {
            0.f32
        }
    let (ct_mult_vec, ct_shift_vec) =
        if (params->is_quant) {
            let scale_division_val = ((ut.toCtTensorF32 <| input_scale) / (ut.toCtTensorF32 <| output_scale))[(0,)]
            let scale_vec = ut.TensorF32(tensor((sz,), scale_val))
            ut.multf32toi32 <| scale_vec <| 32
        } else {
            (ut.EMPTY, ut.EMPTY)
        }
    let ct_round_vec = 
        if (params->is_quant) {
            let shift_val = u.index_uniontensor <| (0,) <| ct_shift_vec
            let mut vec = tensor((sz,), 1i32)
            vec <- (vec << tensor((1,), (shift_val - 1)))
            ut.TensorI32(vec)
        } else {
            ut.EMPTY
        }
    (scale_val, ct_mult_vec, ct_shift_vec, ct_round_vec)


let get_reduction_op_for_loop params innermost_expr =
   

    let rec _reduction_expr params r_idx last_parallel_access pack =
        // we assume reduction loop must exist at least one times
        !{
            for(${params->reduction_itername + toStr(r_idx)} from 0 to ${ll.item <| r_idx <| params->reduce_indices}){
                ${
                    if(r_idx == (params->num_axes - 1)){
                        innermost_expr <| last_parallel_access
                    } else{
                        _reduction_expr <| params <| (r_idx + 1) <| last_parallel_access <| pack
                    }
                }
            }
            ${
                let res = if(r_idx == 0){
                    // store
                    if(params->is_quant){
                        let (scale_val, ct_mult_vec, ct_shift_vec, ct_round_vec) = get_quant_ct_complex_vec <| params->is_quant <| pack

                        if (params->last_parallel_size > 0){
                            !{
                                let mult_vec = cast<i64>(${ut.toRtTensor <| ct_mult_vec})
                                let shift_vec = ${ut.toRtTensor <| ct_shift_vec}
                                let round_vec = ${ut.toRtTensor <| ct_round_vec}
                                let multiplied = cast<i32>((mult_vec * cast<i64>(${params->reduction_vecname})) >> tensor((1,),31))
                                let rounded = multiplied + round_vec
                                let shifted = rounded >> shift_vec
                                // ASSUME tensor-wise quantization scheme for tensor
                                let accum_vec = shifted + ${ut.toRtTensor <| (get_quant_ct_vec <| pack <| (u.index_uniontensor <| (0,) <| output_zero_point))} 
                                ${params->reshaped_output_name}[${ll.toRtTuple <| (ll.concat <| params->output_access <| last_parallel_access)}] <- cast<i8>(accum_vec)
                            }
                        } else{
                            let (mult, shift) =
                                if (params->is_quant) {
                                    let scale_vec = ut.TensorF32(tensor((1,), scale_val))
                                    let (mult_vec, shift_vec) = ut.multf32toi32 <| scale_vec <| 32
                                    let mult = u.index_uniontensor <| (0,) <| mult_vec
                                    let shift = u.index_uniontensor <| (0,) <| shift_vec
                                    (mult, shift)
                                } else {
                                    (1i32, 0i32)
                                }
                            let round = 
                                if (params->is_quant) {
                                    1i32 << (shift - 1)
                                } else {
                                    0i32
                                }
                            !{
                                let multiplied = cast<i32>((cast<i64>(${mult}) * cast<i64>(acc)) >> 31)
                                let rounded = multiplied + ${round}
                                let shifted = rounded >> ${shift}
                                let accum_acc = shifted + ${out_zero_val}
                                batchoutput[${ll.toRtTuple <| output_access}] <- cast<i8>(accum_acc)
                            }
                        }
                    } else{
                        !{
                            ${params->reshaped_output_name}[${ll.toRtTuple <| (ll.concat <| params->output_access <| last_parallel_access)}] <- ${params->reduction_vecname}
                        }                        
                    }
                } else{
                    !{
                        _end_
                    }
                }
                res
            }
        }

    let rec impl idx = 
        if (idx < (ll.len <| params->outer_indices)){
            // parallel (but for last parallel)
            !{
                for(${params->parallel_itername + toStr(idx)} from 0 to ${ll.item <| idx <| params->outer_indices}){
                    ${
                        impl <| (idx+1)
                    }
                }
                ${
                    if(idx == 0){
                        !{
                            0
                        }
                    } else{
                        !{
                            _end_
                        }
                    }
                }
            }
        } else{
            // reduction and last parallel
            if (params->last_parallel_size > 0){
                let ((start1, end1), (start2, end2)) = (get_tile_for_one_dim <| params->last_parallel_size <| params->pack)
                !{
                    for (${params->last_parallel_itername + toStr(0)} from ${start1} to ${end1} step ${params->pack}){ // unroll들어가면 바꾸기
                        let mut ${params->reduction_vecname} = ${ut.toRtTensor <| (get_quant_ct_vec <| params->is_quant <| params->pack <| 0i32)}
                        ${
                            _reduction_expr <| params <| 0 <| [!{${params->last_parallel_itername + toStr(0)}: (${params->last_parallel_itername + toStr(0)} + ${params->pack}):1i}] <| params->pack
                        }
                    }
                    let _ = ${
                        if((end2-start2) > 0){
                            !{
                                let mut ${params->reduction_vecname} = ${ut.toRtTensor <| (get_quant_ct_vec <| params->is_quant <| (end2-start2) <| 0i32)}
                                ${
                                    _reduction_expr <| params <| 0 <| [!{${start2}: ${end2}:1i}] <| (end2-start2)
                                }
                            }
                        } else{
                            !{
                                _end_
                            }
                        }
                    }
                    ${
                        if(idx == 0){
                            !{
                                0
                            }
                        } else{
                            !{
                                _end_
                            }
                        }
                    }
                    
                }
            } else{
                !{
                    // CANNOT USE VECTOR THOUGH iteraton name has "vector"
                    let mut ${params->reduction_vecname} = ${
                        if (params->is_quant){
                            !{0i32}
                        } else{
                            !{0.f32}
                        }
                    }
                    let _ = ${
                        _reduction_expr <| params <| 0 <| [] <| 1
                    }
                    ${
                        if(idx == 0){
                            !{
                                0
                            }
                        } else{
                            !{
                                _end_
                            }
                        }
                    }
                }
                
            }
        }
        impl <| 0i
_end_
