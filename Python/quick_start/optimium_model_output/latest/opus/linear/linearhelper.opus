// utils for conv
// scale2multshift
// 
module core
module core.List.List as ll
module common.uniontensor as ut
module common.params as params
module micro.fusion as fsn

let prepareMultShift params =
    match params->weight_scales with
        | ut.EMPTY  -> (ut.EMPTY, ut.EMPTY)
        | _         -> 
            let output_scales = ut.toCtTensorF32 (params->output_scales)
            let input_scales = ut.toCtTensorF32 (params->input_scales)
            let weight_scales = ut.toCtTensorF32 (params->weight_scales)
            let bias_scales = ut.toCtTensorF32 (params->bias_scales)

            let signMask = 0x80000000u32
            let exponentMask = 0x7F800000u32
            let exponentShift = 23u32
            let exponentBias = 127u32
            let fractionMask = 0x007FFFFFu32
            let fractionShift = 7u32
            let fractionOne = 0x00800000u32

            let mut mult = tensor(shapeOf(weight_scales), 0i32)
            let mut shift = tensor(shapeOf(weight_scales), 0i32)

            for (i from 0 to shapeOf(mult)[|0|]){
                let scale = cast<f32>(input_scales[(0,)] * weight_scales[(i,)] / output_scales[(0,)])

                let _ = if (scale > 1f32) 
                    except("scale is larger than 1")
                

                let scale_bits = bitcast<u32>(cast<f32>(scale))
                // let scale_bits = 1u32
                mult[(i,)] <- cast<i32>(((scale_bits & fractionMask) | fractionOne) << fractionShift)
                shift[(i,)] <- (1) * ((exponentBias + 31 - 32 - (scale_bits >> exponentShift)))
            }

            (ut.TensorF32(mult), ut.TensorI32(shift))

let prepareTilePackAndUnroll params = 
    let (batch, inch) = params->input_shape
    let (_, outch) = params->output_shape
    let (unrollbatch, unrollinch, unrolloutch) = params->unroll
    let (packbatch, packinch, packoutch) = params->pack
    
    let rec tilepackunroll start channel pack unroll =
        let subch = (channel - start) % (pack * unroll)
        let end = channel - subch
        let out = ([(start, end)], [pack], [unroll])
        if (subch == 0){
            out
        } else if(subch % pack == 0){
            let nextunroll = subch / pack
            let nextout = tilepackunroll end channel pack nextunroll
            (ll.concat (out[|0|]) (nextout[|0|]), ll.concat (out[|1|]) (nextout[|1|]), ll.concat (out[|2|]) (nextout[|2|]))
        } else if(subch < pack){
            let nextpack = subch
            let nextunroll = 1
            let nextout = tilepackunroll end channel nextpack nextunroll
            (ll.concat (out[|0|]) (nextout[|0|]), ll.concat (out[|1|]) (nextout[|1|]), ll.concat (out[|2|]) (nextout[|2|]))
        } else{
            let nextunroll = subch / pack
            let nextout = tilepackunroll end channel pack nextunroll
            (ll.concat (out[|0|]) (nextout[|0|]), ll.concat (out[|1|]) (nextout[|1|]), ll.concat (out[|2|]) (nextout[|2|]))
        }

    let (tilebatchs, packbatchs, unrollbatchs) = tilepackunroll 0 batch packbatch unrollbatch
    let (tileinchs, packinchs, unrollinchs) = tilepackunroll 0 inch packinch unrollinch
    let (tileoutchs, packoutchs, unrolloutchs) = tilepackunroll  0 outch packoutch unrolloutch

    (tilebatchs, tileinchs, tileoutchs, packbatchs, packinchs, packoutchs, unrollbatchs, unrollinchs, unrolloutchs)

let prepareBias params =
    match params->bias with
        | ut.TensorI32 t    ->
            (
                match params->weight with 
                    | ut.EMPTY      -> params->bias
                    | ut.TensorI8   ->
                        let weight = reshapeTo(params->weight_shape, ut.toCtTensorI8 (params->weight))
                        let bias = ut.toCtTensorI32 (params->bias)
                        let input_zero_points = ut.toCtTensorI32 (params->input_zero_points)
                        let (batch, inch) = params->input_shape
                        let (_, outch) = params->output_shape

                        let mut modifiedbias = tensor((shapeOf(bias)[|0|],), 0i32)

                        // weight [outch kh kw inch]
                        for (q from 0 to outch){
                            let mut accum = 0i32
                            for (p from 0 to inch){
                                accum <- accum + cast<i32>(weight[(p, q)])
                            }
                            accum <- accum * input_zero_points[(0,)]
                            modifiedbias[(q,)] <- bias[(q,)] - accum
                        }
                        ut.TensorI32(modifiedbias)
            )
        | _                 -> params->bias

let prepareWeightAndBias params = 
    let (batch, inch) = params->input_shape
    let (_, outch) = params->output_shape

    let modifiedbias = prepareBias params

    let (tilebatchs, tileinchs, tileoutchs, packbatchs, packinchs, packoutchs, unrollbatchs, unrollinchs, unrolloutchs) = prepareTilePackAndUnroll params

    let packedbias = modifiedbias

    let packedweight = 
        let packing t zero =
            let weightlen = shapeOf(t)[|0|]
            let weight = reshapeTo(params->weight_shape, t)
            let mut packedweight = tensor((weightlen,), zero)
            let mut offset = 0
                for(outchidx from 0 to (ll.len tileoutchs)){
                    let (outchstart, outchend) = ll.item outchidx tileoutchs
                    let unrolloutch = ll.item outchidx unrolloutchs
                    let packoutch = ll.item outchidx packoutchs
                    let unrollpackoutch = unrolloutch * packoutch
                    for(q from outchstart to outchend step unrollpackoutch){
                        for(inchidx from 0 to (ll.len tileinchs)){
                            let (inchstart, inchend) = ll.item inchidx tileinchs
                            let unrollinch = ll.item inchidx unrollinchs
                            let packinch = ll.item inchidx packinchs
                            let unrollpackinch = unrollinch * packinch
                            for(p from inchstart to inchend step unrollpackinch){
                                for(uo from 0 to unrolloutch){
                                    for(ui from 0 to unrollinch){
                                        for(pi from 0 to packinch){
                                            for(po from 0 to packoutch){
                                                packedweight[(offset,)] <- weight[(p + packinch * ui + pi, q + packoutch * uo + po)]
                                                offset <- offset + 1
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            packedweight

        match params->weight with
            | ut.TensorI8 t     ->
                let packedweight = packing t 0i8
                ut.TensorI8(packedweight)
            | ut.TensorF16 t    ->
                let packedweight = packing t 0.f16
                ut.TensorF16(packedweight)
            | ut.TensorF32 t    ->
                let packedweight = packing t 0.f32
                ut.TensorF32(packedweight)
            | ut.EMPTY          -> ut.EMPTY

    (packedweight, packedbias, tilebatchs, tileinchs, tileoutchs, packbatchs, packinchs, packoutchs, unrollbatchs, unrollinchs, unrolloutchs)

type TemplateParameters = {attr_params: params.Attributes, optim_params: params.Optimization, layer_params: ll.List<params.Layerargs>,
    input_data: ll.List<ll.List<ut.UnionTensor>>, input_dtypes: ll.List<ll.List<rtType>>, input_shapes: ll.List<ll.List<i32>>, input_scales: ll.List<ll.List<ut.UnionTensor>>, input_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    output_dtypes: ll.List<ll.List<rtType>>, output_shapes: ll.List<ll.List<i32>>, output_scales: ll.List<ll.List<ut.UnionTensor>>, output_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    input_edges: ll.List<ll.List<tuple<i32, i32>>>, output_edges: ll.List<ll.List<tuple<i32, i32>>>, ismainops: ll.List<boolean>,
    input_t_list: ll.List<rtType>, output_t_list: ll.List<rtType>}

type InternalParameters = {units : i32, use_bias : bool,
    input_t : rtType, input_dtype : rtType, input_shape : tuple<i32, i32, i32, i32>, input_scales : ut.UnionTensor, input_zero_points : ut.UnionTensor,
    output_t : rtType, output_dtype : rtType, output_shape : tuple<i32, i32, i32, i32>, output_scales : ut.UnionTensor, output_zero_points : ut.UnionTensor,
    weight : ut.UnionTensor, weight_shape : tuple<i32, i32, i32, i32>, weight_scales : ut.UnionTensor, weight_zero_points : ut.UnionTensor, 
    bias : ut.UnionTensor, bias_scales : ut.UnionTensor, bias_zero_points : ut.UnionTensor,
    framework : string, unroll : tuple<i32, i32, i32>, pack : tuple<i32, i32, i32>}

type CodeGenParameters = {
    attr_params: params.Attributes,
    isQuant: bool,
    units: i32, use_bias: bool, input_dtype: rtType, output_dtype: rtType,
    mult: ut.UnionTensor, shift : ut.UnionTensor, packedweight : ll.List, packedbias : ut.UnionTensor, input_zero_points : ut.UnionTensor, output_zero_points : ut.UnionTensor,
    pack : tuple<i32, i32, i32>, unroll : tuple<i32, i32, i32>,
    input_shape : tuple<i32, i32>, output_shape : tuple<i32, i32>, weight_shape : tuple<i32, i32>,
    // tile : (start, end) for loop generation
    // unroll : number of unrolling
    // pack : size of vector
    tilebatchs : ll.List<tuple<i32, i32>>, tileinchs : ll.List<tuple<i32, i32>>, tileoutchs : ll.List<tuple<i32, i32>>, 
    packbatchs : ll.List<i32>, packinchs : ll.List<i32>, packoutchs : ll.List<i32>, 
    unrollbatchs : ll.List<i32>, unrollinchs : ll.List<i32>, unrolloutchs : ll.List<i32>,
    iternamebatch : str, iternameinch : str, iternameoutch : str,
    prefixinput : str, prefixoutput : str, prefixweight : str, prefixweightidx : str, prefixsum : str, prefixinputsubview : str, prefixmult : str, prefixshift : str,
    nameweight : str, namebias : str, namezeropoints : str, namebatchinput : str, namebatchoutput : str, nameinput : str, nameoutput : str, namemult : str, nameshift : str,
    setvarsimpls : ll.List, premicroopsimpls: ll.List, postmicroopsimpls : ll.List, inputpadopsimpls: ll.List, outputpadopsimpls: ll.List, loopopsimpls : ll.List,
}

let initCodeGen templateparams params = 
    let (setvarsimpls, premicroopsimpls, postmicroopsimpls, inputpadopsimpls, outputpadopsimpls, loopopsimpls) = fsn.init (templateparams->layer_params) (templateparams->input_data) (templateparams->input_dtypes) (templateparams->input_shapes) (templateparams->input_scales) (templateparams->input_zero_points) (templateparams->output_dtypes) (templateparams->output_shapes) (templateparams->output_scales) (templateparams->output_zero_points) (templateparams->input_edges) (templateparams->output_edges) (templateparams->ismainops)

    let (mult, shift) = prepareMultShift params
    // let (inputpatterns, inputpatternsteps, inputpatternlens, inputpatternoffsets, tileoutrows, tileoutcols, unrolloutrows, unrolloutcols) = prepareInputPattern params
    let (packedweight, packedbias, tilebatchs, tileinchs, tileoutchs, packbatchs, packinchs, packoutchs, unrollbatchs, unrollinchs, unrolloutchs) = prepareWeightAndBias params

    let codeGenParameters =
        CodeGenParameters(
            templateparams->attr_params,
            ut.isQuant (params->weight),
            params->units, params->use_bias, params->input_dtype, params->output_dtype,
            mult, shift, packedweight, packedbias, params->input_zero_points, params->output_zero_points,
            params->pack, params->unroll, params->input_shape, params->output_shape, params->weight_shape,
            tilebatchs, tileinchs, tileoutchs, 
            packbatchs, packinchs, packoutchs,
            unrollbatchs, unrollinchs, unrolloutchs,
            "b", "p", "q", 
            "i", "o", "w", "widx", "acc", "isub", "m", "sh", 
            "weight", "bias", "zero", "batchinput", "batchoutput", "input", "output", "mult", "shift",
            setvarsimpls, premicroopsimpls, postmicroopsimpls, inputpadopsimpls, outputpadopsimpls, loopopsimpls,
        )

    codeGenParameters

///////////////////////////////////////////////////////
///////////     runtime expr gen codes     ////////////
///////////////////////////////////////////////////////
type IndexesKeys =
    | Batch
    | Inch
    | Outch
    | Weightrow
    | Weightcol
    | Inchpack

    
type Indexes = {batch : i32, inch : i32, outch : i32}

let updateIndexes idxs key val = 
    match key with
        | Batch         -> Indexes(val, idxs->inch, idxs->outch)
        | Inch          -> Indexes(idxs->batch, val, idxs->outch)
        | Outch         -> Indexes(idxs->batch, idxs->inch, val)

type UnrollIndexes = {batch : i32, inch : i32, outch : i32, inchpack : i32}

let updateUnrollIndexes idxs key val = 
    match key with
        | Batch     -> UnrollIndexes(val, idxs->batch, idxs->outch, idxs->inchpack)
        | Inch      -> UnrollIndexes(idx->batch, val, idxs->outch, idxs->inchpack)
        | Outch     -> UnrollIndexes(idx->batch, idxs->inch, val, idxs->inchpack)
        | Inchpack  -> UnrollIndexes(idx->batch, idxs->inch, idxs->outch, val)

type Optree<a> =
    | End of a
    | Op of a * Optree<a>
    | Block of a * Optree<a> * Optree<a>

let getop optree = 
    match optree with
    | End(op)                       -> (op, op)
    | Op(op, nextop)                -> (op, nextop)
    | Block(op, innerop, nextop)    -> (op, Op(innerop, nextop))

let getblock optree =
    let (innerops, nextops) = getop optree
    let (innerop, inneropsnew) = getop innerops
    let (nextop, nextopsnew) = getop nextops
    (innerop, inneropsnew, nextop, nextopsnew)

type VarNames = 
    | Input
    | Weight
    | Weightidx
    | Bias
    | Output
    | Sum
    | Inputpattern
    | Inputpatternidx
    | Inputsubview
    | Mult
    | Shift

let getVarName target uidxs params idxs = 
    match target with
        | Input             -> params->prefixinput + toStr(ll.item (idxs->batch) (params->packbatchs)) + "x" + toStr(ll.item (idxs->inch) (params->packinchs)) + "x" + ut.dtypeStr(params->packedweight) + "u" + toStr(uidxs->batch) + toStr(uidxs->inch)
        | Weight            -> params->prefixweight + toStr(ll.item (idxs->outch) (params->packoutchs)) + "x" + ut.dtypeStr(params->packedweight)
        | Weightidx         -> params->prefixweightidx
        | Sum               -> params->prefixsum + toStr(ll.item (idxs->outch) (params->packoutchs)) + "x" + ut.dtypeStr(params->packedbias) + "u" + toStr(uidxs->batch) + toStr(uidxs->outch) 
        | Inputsubview      -> params->prefixinputsubview + toStr(ll.item (idxs->batch) (params->packbatchs)) + "x" + toStr(ll.item (idxs->inch) (params->packinchs))+ "x" + ut.dtypeStr(params->packedweight) + "u" + toStr(uidxs->batch) + toStr(uidxs->inch)
        | Mult              -> params->prefixmult + toStr(ll.item (idxs->outch) (params->packoutchs)) + "x" + ut.dtypeStr(params->mult) + "u" + toStr(uidxs->outch) 
        | Shift             -> params->prefixshift + toStr(ll.item (idxs->outch) (params->packoutchs)) + "x" + ut.dtypeStr(params->shift) + "u" + toStr(uidxs->outch) 

let getUnrolls params idxs =
    (ll.item (idxs->batch) (params->unrollbatchs), ll.item (idxs->inch) (params->unrollinchs), ll.item (idxs->outch) (params->unrolloutchs))

let genRuntimeCode params idxs ops =
    match ops with
    | End(op)                       -> op params idxs ops
    | Op(op, nextop)                -> op params idxs nextop
    | Block(op, innerop, nextop)    -> op params idxs (Op(innerop, nextop))

let endExpr params idxs ops =
    !{
        // let ${"debugMessageEnd"} = ${toStr(idxs)}
        _end_
    }

let zeroExpr params idxs ops =
    !{
        // let ${"debugMessageEnd"} = ${toStr(idxs)}
        0
    }

// let setBatchInputOutputExpr params idxs ops = 
//     let (nextop, opsnew) = getop(ops)
//     let namebatchinput = params->namebatchinput
//     let namebatchoutput = params->namebatchoutput
//     let (batch, inrows, incols, inch) = params->input_shape
//     let (_, outrows, outcols, outch) = params->output_shape
//     !{
//         let mut ${namebatchoutput} = &outputs[|0|]
//         let ${namebatchinput} = inputs[|0|]
//         ${nextop params idxs opsnew}
//     }
let setBatchInputOutputExpr params idxs ops = 
    let (nextop, opsnew) = getop(ops)
    let namebatchinput = params->namebatchinput
    let namebatchoutput = params->namebatchoutput
    let (batch, inch) = params->input_shape
    let (_, outch) = params->output_shape
    // !{
    //     let mut ${namebatchoutput} = reshapeTo((${batch * outrows * outcols * outch},), &outputs[|0|])
    //     let mut ${namebatchinput} = reshapeTo((${(batch + 1) * inrows * incols * inch},), inputs[|0|])
    //     ${nextop params idxs opsnew}
    // }
    let loopopsimpls = params->loopopsimpls
    let outputnames = ["outputs"]
    let loopopsexpr = fsn.genLoopOpsExpr loopopsimpls outputnames

    let setvarsimpls = params->setvarsimpls
    let batchinputnames = [namebatchinput; "f"; "f"]
    let batchoutputnames = [namebatchoutput]
    let inputshapes = [ [batch; inch]; [0]; [0] ]
    let outputshapes = [ [batch; outch] ]
    let ismutinputs = [true; false; false]
    loopopsexpr (fsn.genSetVarsExpr setvarsimpls batchinputnames batchoutputnames inputshapes outputshapes ismutinputs (nextop params idxs opsnew))

let setWeightExpr params idxs ops =
    let (nextop, opsnew) = getop(ops)
    let nameweight = params->nameweight
    let weight = params->packedweight
    let nameweightidx = getVarName Weightidx (UnrollIndexes(0, 0, 0, 0)) params idxs
    match weight with
        | ut.EMPTY  ->
            !{
                let ${nameweight} = inputs[|1|]
                ${nextop params idxs opsnew}
            }
        | _         ->
            !{
                // let ${nameweight} = ${ut.toRtTensorWithShape weight (params->weight_shape)}
                let ${nameweight} = ${ut.toRtTensor weight}
                // let mut ${nameweightidx} = 0
                ${nextop params idxs opsnew}
            }

let setWeightIdxExpr params idxs ops =
    let (nextop, opsnew) = getop(ops)
    let nameweight = params->nameweight
    let weight = params->packedweight
    let nameweightidx = getVarName Weightidx (UnrollIndexes(0, 0, 0, 0)) params idxs
    match weight with
        | ut.EMPTY  ->
            !{
                // let ${nameweight} = inputs[|1|]
                ${nextop params idxs opsnew}
            }
        | _         ->
            !{
                // let ${nameweight} = ${ut.toRtTensorWithShape weight (params->weight_shape)}
                // let ${nameweight} = ${ut.toRtTensor weight}
                let mut ${nameweightidx} = 0
                ${nextop params idxs opsnew}
            }

let setBiasExpr params idxs ops =
    let (nextop, opsnew) = getop(ops)
    let namebias = params->namebias
    let bias = params->packedbias
    let (_, outch) = params->output_shape
    // if(params->use_bias){
    match bias with
        | ut.EMPTY  ->
            !{
                ${nextop params idxs opsnew}
            }
        | _         ->
            !{
                // let ${namebias} = ${ut.toRtTensorWithShape bias (1, outch)}
                let ${namebias} = ${ut.toRtTensor bias}
                ${nextop params idxs opsnew}
            }

let setZeropointsExpr params idxs ops =
    let (nextop, opsnew) = getop(ops)
    let namezeropoints = params->namezeropoints
    let zero = params->output_zero_points
    if(params->isQuant){
        !{
            // let ${namezeropoints} = ${ut.toRtTensorWithShape zero (1, 1)}
            let ${namezeropoints} = ${ut.toRtTensor zero}
            ${nextop params idxs opsnew}
        }
    } else{
        !{
            ${nextop params idxs opsnew}
        }
    }

let setMultShiftExpr params idxs ops = 
    let (nextop, opsnew) = getop(ops)
    let namemult = params->namemult
    let nameshift = params->nameshift

    if(params->isQuant){
        !{
            // let ${namemult} = ${ut.toRtTensorWithShape (params->mult) (1, 1)}
            // let ${nameshift} = ${ut.toRtTensorWithShape (params->shift) (1, 1)}
            let ${namemult} = ${ut.toRtTensor (params->mult)}
            let ${nameshift} = ${ut.toRtTensor (params->shift)}
            ${nextop params idxs opsnew}
        }
    } else{
        !{
            ${nextop params idxs opsnew}
        }
    }

let setWeightidxExpr params idxs ops =
    let (nextop, opsnew) = getop(ops)
    let uidxs = UnrollIndexes(0, 0, 0, 0, 0, 0)
    let nameweightidx = getVarName Weightidx uidxs params idxs

    !{
        let mut ${nameweightidx} = 0
        ${nextop params idxs opsnew}
    }

/// Tiled channel loop expression
// generate tiled input or output channel loop
// target: 0 (input), 1 (output)
// params->iternameinchs/outchs : string, itername
// params->packinchs/outchs : tuple<i32>, packing parameters 
// params->unrollinchs/outchs : tuple<i32>, unrolling parameters
// params->loopinchs/outchs : tuple<tuple<i32>>, loop parameters, (start, end)
// number of element in pack, unroll and loop should be same
// idxs->inchidx/outchidx : i32, index to select parameter
let rec genTiledLoopExpr index target params idxs ops = 
    let (innerop, inneropsnew, nextop, nextopsnew) = getblock ops
    let tilelen = if(target == 0){ll.len (params->tilebatchs)} else if(target == 1){ll.len (params->tileinchs)} else{ll.len (params->tileoutchs)}
    if (index == tilelen){
        let idxsnew = if(target == 0){
            updateIndexes idxs Batch 0
        } else if(target == 1){
            updateIndexes idxs Inch 0
        } else{
            updateIndexes idxs Outch 0
        }
        nextop params idxsnew nextopsnew
    } else{
        let (idxsnew, pack, unroll, groupedch, (start, end), itername) = if(target == 0){
                let subidx = idxs->batch
                let idxsnew = updateIndexes idxs Batch (index + 1)
                let (batch, _) = params->input_shape
                (idxsnew, ll.item subidx (params->packbatchs), ll.item subidx (params->unrollbatchs), batch, ll.item subidx (params->tilebatchs), params->iternamebatch)
            } else if(target == 1){
                let subidx = idxs->inch
                let idxsnew = updateIndexes idxs Inch (index + 1)
                let (_, inch) = params->input_shape
                (idxsnew, ll.item subidx (params->packinchs), ll.item subidx (params->unrollinchs), inch, ll.item subidx (params->tileinchs), params->iternameinch)
            } else{
                let subidx = idxs->outch
                let idxsnew = updateIndexes idxs Outch (index + 1)
                let (_, outch) = params->output_shape
                (idxsnew, ll.item subidx (params->packoutchs), ll.item subidx (params->unrolloutchs), outch, ll.item subidx (params->tileoutchs), params->iternameoutch)
            } 
        // tmp parallel impl
        let (batch, _) = params->input_shape
        if(((batch > 10) && (target == 0)) || ((batch <= 10) && (target == 1))){
            let isparallel = (params->attr_params->num_threads < (end - start)) && (params->attr_params->num_threads > 1) 
            !{
                attr [ Parallel: isparallel ]
                for(${itername} from ${start} to ${end} step ${pack * unroll}){
                    ${innerop params idxs inneropsnew}
                }
                ${genTiledLoopExpr (index + 1) target params idxsnew ops}
            }
        // } else if((batch <= 10) && (target == 1)){
        //     !{
        //         attr [ Parallel: params->attr_params->num_threads < (end - start) ]
        //         for(${itername} from ${start} to ${end} step ${pack * unroll}){
        //             ${innerop params idxs inneropsnew}
        //         }
        //         ${genTiledLoopExpr (index + 1) target params idxsnew ops}
        //     }
        } else {
            !{
                for(${itername} from ${start} to ${end} step ${pack * unroll}){
                    ${innerop params idxs inneropsnew}
                }
                ${genTiledLoopExpr (index + 1) target params idxsnew ops}
            }
        }
    }

let tiledBatchLoopExpr params idxs ops = 
    genTiledLoopExpr 0 0 params idxs ops

let tiledInputChannelLoopExpr params idxs ops = 
    genTiledLoopExpr 0 1 params idxs ops

let tiledOutputChannelLoopExpr params idxs ops = 
    genTiledLoopExpr 0 2 params idxs ops

// Load sum expression
let unrolledLoadSumExpr params idxs ops = 
    let unrollidxs = UnrollIndexes(0, 0, 0, 0)
    let (unrollbatch, unrollinch, unrolloutch) = getUnrolls params idxs
    let packbatch = ll.item (idxs->batch) (params->packbatchs)
    let packoutch = ll.item (idxs->outch) (params->packoutchs)
    let namebias = params->namebias

    let rec genExpr index uidxs =
        let sumname = getVarName Sum uidxs params idxs
        let (batchidx, inchidx, outchidx) = (uidxs->batch, uidxs->inch, uidxs->outch)
        if (index == unrollbatch * unrolloutch) {
            let (nextop, opsnew) = getop ops
            nextop params idxs opsnew
        } else{
            let (batchidxnew, inchidxnew, outchidxnew) =
                if (outchidx + 1 == unrolloutch) {
                    (batchidx + 1, inchidx, 0)
                } else{
                    (batchidx, inchidx, outchidx + 1)
                }
            let zero = if(params->isQuant){
                let zero_point = (ut.toCtTensorI32 (params->output_zero_points))[(0,)]
                !{${zero_point}}
            } else if(params->output_dtype == rtType(f16)){
                !{0.f16}
            } else{
                !{0.f32}
            }
            let expr = 
                if(params->use_bias){
                    !{${namebias}[(${params->iternameoutch} + ${outchidx * packoutch}:${params->iternameoutch} + ${(outchidx + 1) * packoutch}:1,)]}
                } else{
                    !{tensor((${packoutch},), ${zero})}
                }
            !{
                let mut ${sumname} = ${expr}
                // let mut ${sumname} = ${expr}
                ${genExpr (index + 1) (UnrollIndexes(batchidxnew, inchidxnew, outchidxnew, 0))}
            }
        }
    
    genExpr 0 unrollidxs

let unrolledInputSubviewExpr params idxs ops =
    let unrollidxs = UnrollIndexes(0, 0, 0, 0)
    let (unrollbatch, unrollinch, unrolloutch) = getUnrolls params idxs
    let (batchstart, batchend) = ll.item (idxs->batch) (params->tilebatchs)
    let (inchstart, inchend) = ll.item (idxs->inch) (params->tileinchs)
    let packbatch = ll.item (idxs->batch) (params->packbatchs)
    let packinch = ll.item (idxs->inch) (params->packinchs)

    let rec genExpr index uidxs =
        let nameisubview = getVarName Inputsubview uidxs params idxs
        let nameinput = params->namebatchinput
        let iternamebatch = params->iternamebatch
        let iternameinch = params->iternameinch
        let (batchidx, inchidx, outchidx) = (uidxs->batch, uidxs->inch, uidxs->outch)
        if (index == unrollbatch * unrollinch) {
            let (nextop, opsnew) = getop ops
            nextop params idxs opsnew
        } else{
            let (batchidxnew, inchidxnew) =
                if ((inchidx + 1 == unrollinch)){
                    (batchidx + 1, 0)
                } else{
                    (batchidx, inchidx + 1)
                }
            !{
                // let ${nameisubview} = ${nameinput}[(${iternamebatch} + ${packbatch * batchidx}:${iternamebatch} + ${packbatch * (batchidx + 1)}:1,${inchstart}:${inchend}:1)]
                ${genExpr (index + 1) (UnrollIndexes(batchidxnew, inchidxnew, 0, 0))}
            }
        }
    
    genExpr 0 unrollidxs

// unrolld load input, load weight, and fma
// unrolled along outch, inch{    
//   load weight
//   unrolled along outrows, outcols{
//     loadinput
//     fma   
//   }
// }
let unrolledLoadInputWeightAndFMAExpr params idxs ops = 
    let unrollidxs = UnrollIndexes(0, 0, 0, 0)
    // let nameinput = params->namebatchinput
    let nameweight = params->nameweight
    let (unrollbatch, unrollinch, unrolloutch) = getUnrolls params idxs
    let packbatch = ll.item (idxs->batch) (params->packbatchs)
    let packinch = ll.item (idxs->inch) (params->packinchs)
    let packoutch = ll.item (idxs->outch) (params->packoutchs)
    let tilebatchslen = ll.len (params->tilebatchs)
    let tileoutchslen = ll.len (params->tileoutchs)
    let tileinchslen = ll.len (params->tileinchs)
    let (batch, inch) = params->input_shape
    let (_, outch) = params->output_shape
    let premicroopsimpls = params->premicroopsimpls

    let loadInputExpr uidxs params idxs nextop = 
        let inchOffset uidxs =
            let (rowidx, colidx, inchidx, outchidx, wrowidx, wcolidx) = (uidxs->outrow, uidxs->outcol, uidxs->inch, uidxs->outch, uidxs->weightrow, uidxs->weightcol)
            !{${params->iternameinch} + ${inchidx * packinch}}

        let (batchidx, inchidx, outchidx, inchpackidx) = (uidxs->batch, uidxs->inch, uidxs->outch, uidxs->inchpack)

        let input = getVarName Input uidxs params idxs
        let nameinputsubview = getVarName Inputsubview uidxs params idxs
        let namebatchinput = params->namebatchinput
        let iternamebatch = params->iternamebatch
        let iternameinch = params->iternameinch

        let vectorsize = packinch
        let vectordtype =
            match (params->packedweight) with
                | ut.TensorF32 x -> rtType(f32)
                | ut.TensorF16 x -> rtType(f16)
                | ut.TensorI8 x -> rtType(i32)
        let fusedExpr = fsn.genMicroOpsExpr premicroopsimpls input input ([!{${iternamebatch} + ${batchidx}};!{${iternameinch} + ${inchidx * packinch}}]) vectorsize vectordtype

        if(outchidx == 0 && inchpackidx == 0){
            // let expr = !{${nameinputsubview}[(${packbatch * batchidx}:${packbatch * (batchidx + 1)}:1,${iternameinch} + ${inchidx}:${iternameinch} + ${inchidx + 1}:1)]}
            let expr = !{${namebatchinput}[(${iternamebatch} + ${batchidx},${iternameinch} + ${inchidx * packinch}:${iternameinch} + ${inchidx * packinch + packinch}:1)]}
            if(params->isQuant){
                !{
                    let ${input} = cast<i16>(${expr})
                    ${nextop}
                }
            } else{
                !{
                    let mut ${input} = ${expr}
                    ${fusedExpr nextop}
                }
            }
        } else{
            !{
                ${nextop}
            }
        }

    let loadWeightExpr uidxs uidxs_old params idxs nextop = 
        let weight = getVarName Weight uidxs params idxs
        let weightidx = getVarName Weightidx uidxs params idxs
        let iternamebatch = params->iternamebatch
        let iternameinch = params->iternameinch
        let iternameoutch = params->iternameoutch

        let batchidx, inchidx, outchidx, inchpackidx = uidxs->batch, uidxs->inch, uidxs->outch, uidxs->inchpack
        let batchidx_old, inchidx_old, outchidx_old, inchpackidx_old = uidxs_old->batch, uidxs_old->inch, uidxs_old->outch, uidxs_old->inchpack
        let updateflag = (inchidx != inchidx_old) || (outchidx != outchidx_old) || (inchpackidx != inchpackidx_old)

        let loadweightexpr = 
            match params->packedweight with
                | ut.EMPTY  ->
                    !{${params->nameweight}[(${iternameinch}, ${iternameoutch} + ${packoutch * outchidx}:${iternameoutch} + ${packoutch * (outchidx + 1)}:1,)]}
                | _         ->
                    !{${params->nameweight}[(${weightidx}:${weightidx} + ${packoutch}:1,)]}
        let updateweightexpr nextop = 
            match params->packedweight with
                | ut.EMPTY  -> nextop
                | _         ->
                    !{
                        ${weightidx} <- ${weightidx} + ${packoutch}
                        ${nextop}
                    }
        // if((batchidx == 0) && (inchidx == 0) && (outchidx == 0)){
        if((batchidx == 0) && (outchidx == 0) && (inchidx == 0) && (inchpackidx == 0)){
            if(params->isQuant){
                !{
                    let mut ${weight} = cast<i16>(${loadweightexpr})
                    ${updateweightexpr nextop}
                }
            } else{
                !{
                    let mut ${weight} = ${loadweightexpr}
                    ${updateweightexpr nextop}
                }
            }
        } else if(updateflag){
            if(params->isQuant){
                !{
                    ${weight} <- cast<i16>(${loadweightexpr})
                    ${updateweightexpr nextop}
                }
            } else{
                !{
                    ${weight} <- ${loadweightexpr}
                    ${updateweightexpr nextop}
                }
            }
        } else{
            !{
                ${nextop}
            }
        }

    let executeFMAExpr uidxs params idxs nextop =
        let rec genExpr index uidxs params idxs nextop =
            if(index == 1){
                nextop
            } else{
                let input = getVarName Input uidxs params idxs
                let weight = getVarName Weight uidxs params idxs
                let sum = getVarName Sum uidxs params idxs
                let startidx = uidxs->inchpack

                if(packinch == 1){
                    if(params->isQuant){
                        !{
                            ${sum} <- ${sum} + cast<i32>(${input}[(${startidx}:${startidx + 1}:1,)] * ${weight})
                            ${genExpr (index + 1) uidxs params idxs nextop}
                        }
                    } else{
                        !{
                            ${sum} <- ${sum} + ${input}[(${startidx}:${startidx + 1}:1,)] * ${weight}
                            ${genExpr (index + 1) uidxs params idxs nextop}
                        }
                    }
                } else{
                    if(params->isQuant){
                        !{
                            ${sum} <- ${sum} + cast<i32>(${input}[(${startidx}:${startidx + 1}:1,)] * ${weight})
                            ${genExpr (index + 1) uidxs params idxs nextop}
                        }
                    } else{
                        !{
                            ${sum} <- ${sum} + ${input}[(${startidx}:${startidx + 1}:1,)] * ${weight}
                            ${genExpr (index + 1) uidxs params idxs nextop}
                        }
                    }
                }
            }
        genExpr 0 uidxs params idxs nextop


    let rec genExpr index uidxs uidxs_old = 
        let (batchidx, inchidx, outchidx, inchpackidx) = (uidxs->batch, uidxs->inch, uidxs->outch, uidxs->inchpack)
        let stopflag = unrollbatch * unrollinch * unrolloutch * packinch
        if(index == stopflag){
            let (nextop, opsnew) = getop ops
            let idxsnew = updateIndexes idxs Inch 0
            nextop params idxsnew opsnew
        } else{
            let (batchidxnew, inchidxnew, outchidxnew, inchpackidxnew) =
                if ((batchidx + 1 == unrollbatch) && (inchpackidx + 1 == packinch) && (inchidx + 1 == unrollinch)){
                    (0, 0, outchidx + 1, 0)
                } else if ((batchidx + 1 == unrollbatch) && (inchpackidx + 1 == packinch)){
                    (0, inchidx + 1, outchidx, 0)
                } else if (batchidx + 1 == unrollbatch){
                    (0, inchidx, outchidx, inchpackidx + 1)
                } else {
                    (batchidx + 1, inchidx, outchidx, inchpackidx)
                }

            let loadInput = loadInputExpr uidxs params idxs 
            let loadWeight = loadWeightExpr uidxs uidxs_old params idxs
            let executeFMA = executeFMAExpr uidxs params idxs
            
            loadInput (loadWeight (executeFMA (genExpr (index + 1) (UnrollIndexes(batchidxnew, inchidxnew, outchidxnew, inchpackidxnew)) uidxs)))
        }
    genExpr 0 unrollidxs unrollidxs

let unrolledStoreExpr params idxs ops = 
    let unrollidxs = UnrollIndexes(0, 0, 0, 0)
    let nameinput = params->nameinput
    let nameweight = params->nameweight
    let (unrollbatch, unrollinch, unrolloutch) = getUnrolls params idxs
    let packbatch = ll.item (idxs->batch) (params->packbatchs)
    let packinch = ll.item (idxs->inch) (params->packinchs)
    let packoutch = ll.item (idxs->outch) (params->packoutchs)
    let tileoutchslen = ll.len (params->tileoutchs)
    let tileinchslen = ll.len (params->tileinchs)
    let (batch, inch) = params->input_shape
    let (_, outch) = params->output_shape

    let rec genExpr index uidxs = 
        let (batchidx, inchidx, outchidx) = (uidxs->batch, uidxs->inch, uidxs->outch)
        // if(index == unrollrow * unrollcol * unrollinch * unrolloutch){
        if(index == unrollbatch * unrolloutch){
            let (nextop, opsnew) = getop ops
            let idxsnew = updateIndexes idxs Inch 0
            nextop params idxsnew opsnew
        } else{
            let (batchidxnew, inchidxnew, outchidxnew) =
                if((outchidx + 1 == unrolloutch)){
                    (batchidx + 1, 0, 0)
                } else{
                    (batchidx, 0, outchidx + 1)
                }
            if(params->isQuant){
                // let mult = getVarName Mult uidxs params idxs
                // let shift = getVarName Shift uidxs params idxs
                let mult = params->namemult
                let shift = params->nameshift
                let sum = getVarName Sum uidxs params idxs
                let zero = params->namezeropoints
                let output = params->namebatchoutput
                let iternamebatch = params->iternamebatch
                !{
                    // let _ = vqdmulhq(${sum}, ${mult})
                    ${sum} <- cast<i32>((cast<i64>(${sum}) * cast<i64>(${mult}) >> tensor((1, 1), 31i32)))
                    ${sum} <- (${sum} + (tensor((1, 1), {1i32}) << (${shift} - tensor((1, 1), {1i32})))) >> ${shift}
                    ${sum} <- ${sum} + ${zero}
                    ${output}[(${iternamebatch}, ${params->iternameoutch} + ${outchidx * packoutch}:${params->iternameoutch} + ${outchidx * packoutch + packoutch}:1,)] <- cast<i8>(${sum})
                    ${genExpr (index + 1) (UnrollIndexes(batchidxnew, inchidxnew, outchidxnew))}
                }
            } else{
                let sum = getVarName Sum uidxs params idxs
                let output = params->namebatchoutput
                let iternamebatch = params->iternamebatch
                let outchidxname = params->iternameoutch + toStr(outchidx)
                let prefusionExpr nextop = 
                    if(batchidx == 0){
                        !{
                            let ${outchidxname} = ${params->iternameoutch} + ${outchidx * packoutch}
                            ${nextop}
                        }
                    } else{
                        nextop
                    }
                let postfusionExpr =
                    !{
                        // ${output}[(${iternamebatch}, ${params->iternameoutch} + ${outchidx * packoutch}:${params->iternameoutch} + ${outchidx * packoutch + packoutch}:1,)] <- ${sum}
                        ${output}[(${iternamebatch} + ${batchidx}, ${outchidxname}:${outchidxname} + ${packoutch}:1,)] <- ${sum}
                        ${genExpr (index + 1) (UnrollIndexes(batchidxnew, inchidxnew, outchidxnew, 0))}
                    }
                let microopsimpls = params->postmicroopsimpls
                let vectordtype =
                    match (params->packedweight) with
                        | ut.TensorF32 x -> rtType(f32)
                        | ut.TensorF16 x -> rtType(f16)
                        | ut.TensorI8 x -> rtType(i32)
                let fusionExpr = fsn.genMicroOpsExpr microopsimpls sum sum ([!{${iternamebatch} + ${batchidx}}; !{${outchidxname}}]) packoutch vectordtype
                prefusionExpr (fusionExpr postfusionExpr)
            }
        }

    genExpr 0 unrollidxs


_end_