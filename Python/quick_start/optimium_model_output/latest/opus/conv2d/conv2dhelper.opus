// utils for conv
// scale2multshift
// 
module core
module core.List.List as ll
module common.uniontensor as ut
module common.params as params
module micro.fusion as fsn

let prepareMultShift params =
    match params->weight_scales with
        | ut.EMPTY  -> (ut.EMPTY, ut.EMPTY)
        | _         -> 
            let output_scales = ut.toCtTensorF32 (params->output_scales)
            let input_scales = ut.toCtTensorF32 (params->input_scales)
            let weight_scales = ut.toCtTensorF32 (params->weight_scales)
            let bias_scales = ut.toCtTensorF32 (params->bias_scales)

            let signMask = 0x80000000u32
            let exponentMask = 0x7F800000u32
            let exponentShift = 23u32
            let exponentBias = 127u32
            let fractionMask = 0x007FFFFFu32
            let fractionShift = 7u32
            let fractionOne = 0x00800000u32

            let mut mult = tensor(shapeOf(weight_scales), 0i32)
            let mut shift = tensor(shapeOf(weight_scales), 0i32)

            for (i from 0 to shapeOf(mult)[|0|]){
                let scale = cast<f32>(input_scales[(0,)] * weight_scales[(i,)] / output_scales[(0,)])

                let _ = if (scale > 1f32) 
                    except("scale is larger than 1")
                

                let scale_bits = bitcast<u32>(cast<f32>(scale))
                // let scale_bits = 1u32
                mult[(i,)] <- cast<i32>(((scale_bits & fractionMask) | fractionOne) << fractionShift)
                shift[(i,)] <- (1) * ((exponentBias + 31 - 32 - (scale_bits >> exponentShift)))
            }

            (ut.TensorF32(mult), ut.TensorI32(shift))

let prepareInputPattern params inputpadopsimpls outputpadopsimpls = 
    
    let (batch, inrows, incols, inch) = params->input_shape
    let (_, outrows, outcols, outch) = params->output_shape
    let (_, weightrows, weightcols, _) = params->weight_shape
    let (unrollrow, unrollcol, unrollinch, unrolloutch) = params->unroll
    let (packinch, packoutch) = params->pack
    let stride = params->stride
    let dilation = params->dilation

    let (padt, padb, padl, padr) = params->padding
    let (padding, input_shape) = fsn.padOps inputpadopsimpls ([[0; 0]; [padt; padb]; [padl; padr]; [0; 0]]) ([batch; inrows; incols; inch])
    let (outpadding, output_shape) = fsn.padOps outputpadopsimpls ([[0; 0]; [0; 0]; [0; 0]; [0; 0]]) ([batch; outrows; outcols; outch])

    let bottomA, rightA = outrows - outrows % unrollrow, outcols - outcols % unrollcol
    let tileA, unrollA = (0, 0, bottomA, rightA), (unrollrow, unrollcol)
    let tileB, unrollB = (0, rightA, bottomA, outcols), (unrollrow, outcols % unrollcol)
    let tileC, unrollC = (bottomA, 0, outrows, rightA), (outrows % unrollrow, unrollcol)
    let tileD, unrollD = (bottomA, rightA, outrows, outcols), (outrows % unrollrow, outcols % unrollcol)

    let genTiledInputPattern tile unroll params = 
        let (striderow, stridecol) = params->stride
        let (dilationrow, dilationcol) = params->dilation
        let (unrollrow, unrollcol) = unroll
        // let (padt, padb, padl, padr) = params->padding
        let (padt, padb, padl, padr) = (ll.item 0 (ll.item 1 padding), ll.item 1 (ll.item 1 padding), ll.item 0 (ll.item 2 padding), ll.item 1 (ll.item 2 padding))
        let (outpadt, outpadb, outpadl, outpadr) = (ll.item 0 (ll.item 1 outpadding), ll.item 1 (ll.item 1 outpadding), ll.item 0 (ll.item 2 outpadding), ll.item 1 (ll.item 2 outpadding))
        let (inrows, incols, inch) = (ll.item 1 input_shape, ll.item 2 input_shape, ll.item 3 input_shape)
        let (outrows, outcols, outch) = (ll.item 1 output_shape, ll.item 2 output_shape, ll.item 3 output_shape)
        let (top, left, bottom, right) = tile

        if ((unrollrow == 0) || (unrollcol == 0))
            let inputpatternstep = 0
            let inputpatternlen = 0
            let mut inputpattern = tensor((1,), 0i32)

            (inputpattern, inputpatternstep, inputpatternlen)
        else
            let inputlength = batch * inrows * incols * inch
            let inputpatternstep = weightcols * weightrows * unrollcol * unrollrow + unrollrow * unrollcol
            let inputpatternlen = ((bottom - top) / unrollrow) * ((right - left) / unrollcol) * inputpatternstep

            let mut offset = 0i
            let mut inputpattern = tensor((inputpatternlen,), 0i32)
            for (i from top to bottom step unrollrow){
                for (j from left to right step unrollcol){
                    for (ui from 0 to unrollrow){
                        for (uj from 0 to unrollcol){
                            for (si from 0 to weightrows){
                                for (sj from 0 to weightcols){
                                    let ii = -padt + striderow * (i + ui) + dilationrow * si
                                    let jj = -padl + stridecol * (j + uj) + dilationcol * sj
                                    let _ = if ((ii >= 0) && (ii <= inrows - 1) && (jj >= 0) && (jj <= incols - 1))
                                        inputpattern[(offset,)] <- inch * jj + inch * incols * ii
                                    else
                                        inputpattern[(offset,)] <- inputlength
                                        _end_
                                    offset <- offset + 1
                                }
                            }
                            inputpattern[(offset,)] <- outch * (outpadl + j + uj) + outch * outcols * (outpadt + i + ui)
                            offset <- offset + 1
                        }
                    }
                }
            }

            (inputpattern, inputpatternstep, inputpatternlen)

    let (inputpatternA, inputpatternstepA, inputpatternlenA) = genTiledInputPattern tileA unrollA params
    let (inputpatternB, inputpatternstepB, inputpatternlenB) = genTiledInputPattern tileB unrollB params
    let (inputpatternC, inputpatternstepC, inputpatternlenC) = genTiledInputPattern tileC unrollC params
    let (inputpatternD, inputpatternstepD, inputpatternlenD) = genTiledInputPattern tileD unrollD params

    let mut inputpatternABCD = tensor((inputpatternlenA + inputpatternlenB + inputpatternlenC + inputpatternlenD,), 0i32)
    let _ = if (inputpatternlenD > 0){ // A, B, C, D
        inputpatternABCD[(0:inputpatternlenA:1,)] <- inputpatternA
        inputpatternABCD[(inputpatternlenA:inputpatternlenA + inputpatternlenB:1,)] <- inputpatternB
        inputpatternABCD[(inputpatternlenA + inputpatternlenB:inputpatternlenA + inputpatternlenB + inputpatternlenC:1,)] <- inputpatternC
        inputpatternABCD[(inputpatternlenA + inputpatternlenB + inputpatternlenC:inputpatternlenA + inputpatternlenB + inputpatternlenC + inputpatternlenD:1,)] <- inputpatternD
        0
    } else if (inputpatternlenC > 0){ // A, C
        inputpatternABCD[(0:inputpatternlenA:1,)] <- inputpatternA
        inputpatternABCD[(inputpatternlenA:inputpatternlenA + inputpatternlenC:1,)] <- inputpatternC
        0
    } else if (inputpatternlenB > 0){ // A, B
        inputpatternABCD[(0:inputpatternlenA:1,)] <- inputpatternA
        inputpatternABCD[(inputpatternlenA:inputpatternlenA + inputpatternlenB:1,)] <- inputpatternB
        0
    } else{ // A
        inputpatternABCD[(0:inputpatternlenA:1,)] <- inputpatternA
        0
    }

    (inputpatternABCD, 
    [inputpatternstepA; inputpatternstepB; inputpatternstepC; inputpatternstepD], 
    [inputpatternlenA; inputpatternlenB; inputpatternlenC; inputpatternlenD], 
    [0; inputpatternlenA; inputpatternlenA + inputpatternlenB; inputpatternlenA + inputpatternlenB + inputpatternlenC],
    [(tileA[|0|], tileA[|2|]); (tileB[|0|], tileB[|2|]); (tileC[|0|], tileC[|2|]); (tileD[|0|], tileD[|2|])], 
    [(tileA[|1|], tileA[|3|]); (tileB[|1|], tileB[|3|]); (tileC[|1|], tileC[|3|]); (tileD[|1|], tileD[|3|])], 
    [unrollA[|0|]; unrollB[|0|]; unrollC[|0|]; unrollD[|0|]],
    [unrollA[|1|]; unrollB[|1|]; unrollC[|1|]; unrollD[|1|]])

let prepareChannelPackAndUnroll params = 
    let groups = params->groups
    let (_, inrows, incols, inch) = params->input_shape
    let (_, outrows, outcols, outch) = params->output_shape
    let (unrollrow, unrollcol, unrollinch, unrolloutch) = params->unroll
    let (packinch, packoutch) = params->pack
    let (_, weightrows, weightcols, _) = params->weight_shape
    let (groupedinch, groupedoutch) = 
        if(params->depthwise){
            if(params->groups == 1){
                (inch, outch / groups)
            } else{
                (inch, outch)
            }
        } else{
            (inch / groups, outch / groups)
        }
    let stride = params->stride
    let dilation = params->dilation
    
    let rec tilechannel start channel pack unroll =
        let subch = (channel - start) % (pack * unroll)
        let end = channel - subch
        let out = ([(start, end)], [pack], [unroll])
        if (subch == 0){
            out
        } else if(subch % pack == 0){
            let nextunroll = subch / pack
            let nextout = tilechannel end channel pack nextunroll
            (ll.concat (out[|0|]) (nextout[|0|]), ll.concat (out[|1|]) (nextout[|1|]), ll.concat (out[|2|]) (nextout[|2|]))
        } else if(subch < pack){
            let nextpack = subch
            let nextunroll = 1
            let nextout = tilechannel end channel nextpack nextunroll
            (ll.concat (out[|0|]) (nextout[|0|]), ll.concat (out[|1|]) (nextout[|1|]), ll.concat (out[|2|]) (nextout[|2|]))
        } else{
            let nextunroll = subch / pack
            let nextout = tilechannel end channel pack nextunroll
            (ll.concat (out[|0|]) (nextout[|0|]), ll.concat (out[|1|]) (nextout[|1|]), ll.concat (out[|2|]) (nextout[|2|]))
        }

    let (tileinchs, packinchs, unrollinchs) = tilechannel 0 groupedinch packinch unrollinch
    let (tileoutchs, packoutchs, unrolloutchs) = tilechannel  0 groupedoutch packoutch unrolloutch

    (tileinchs, tileoutchs, packinchs, packoutchs, unrollinchs, unrolloutchs)

let prepareBias params =
    match params->bias with
        | ut.TensorI32 t    ->
            let weight = reshapeTo(params->weight_shape, ut.toCtTensorI8 (params->weight))
            let bias = ut.toCtTensorI32 (params->bias)
            let input_zero_points = ut.toCtTensorI32 (params->input_zero_points)
            let groups = params->groups
            let depthwise = params->depthwise
            let (_, _, _, inch) = params->input_shape
            let (_, _, _, outch) = params->output_shape
            let (_, weightrows, weightcols, _) = params->weight_shape

            let mut modifiedbias = tensor((shapeOf(bias)[|0|],), 0i32)

            let _ = if (depthwise)
                // weight [outch kh kw inch]
                // let groupedinch = inch
                // let groupedoutch = outch / groups

                for (q from 0 to outch){
                    let mut accum = 0i32
                    for (ki from 0 to weightrows){
                        for(kj from 0 to weightcols){
                            accum <- accum + cast<i32>(weight[(0, ki, kj, q)])
                        }
                    }
                    accum <- accum * input_zero_points[(0,)]
                    modifiedbias[(q,)] <- bias[(q,)] - accum
                }
                _end_
            else
                // weight [outch kh kw inch]
                let groupedinch = inch / groups
                let groupedoutch = outch / groups

                for (g from 0 to groups){
                    for (q from groupedoutch * g to groupedoutch * (g + 1)){
                        let mut accum = 0i32
                        for (ki from 0 to weightrows){
                            for(kj from 0 to weightcols){
                                for (p from 0 to groupedinch){
                                    accum <- accum + cast<i32>(weight[(p, ki, kj, q)])
                                }
                            }
                        }
                        accum <- accum * input_zero_points[(0,)]
                        modifiedbias[(q,)] <- bias[(q,)] - accum
                    }
                }
                _end_
            ut.TensorI32(modifiedbias)
        | _                 -> params->bias

let prepareWeightAndBias params = 
    let groups = params->groups
    let depthwise = params->depthwise
    let (_, weightrows, weightcols, _) = params->weight_shape
    let (_, _, _, inch) = params->input_shape
    let (_, _, _, outch) = params->output_shape
    let groupedinch = inch / groups
    let groupedoutch = outch / groups

    let modifiedbias = prepareBias params

    let (tileinchs, tileoutchs, packinchs, packoutchs, unrollinchs, unrolloutchs) = prepareChannelPackAndUnroll params

    let packedbias = modifiedbias

    let packedweight = 
        let packing t zero =
            let weightlen = shapeOf(t)[|0|]
            let weight = reshapeTo(params->weight_shape, t)
            let mut packedweight = tensor((weightlen,), zero)
            let mut offset = 0
            if(params->depthwise){
                if(groups == 1){
                    for(g from 0 to groups){
                        for(outchidx from 0 to (ll.len tileoutchs)){
                            let (outchstart, outchend) = ll.item outchidx tileoutchs
                            let unrolloutch = ll.item outchidx unrolloutchs
                            let packoutch = ll.item outchidx packoutchs
                            let unrollpackoutch = unrolloutch * packoutch
                            for(q from g * groupedoutch + outchstart to g * groupedoutch + outchend step unrollpackoutch){
                                for(si from 0 to weightrows){
                                    for(sj from 0 to weightcols){
                                        for(uo from 0 to unrolloutch){
                                            for(po from 0 to packoutch){
                                                packedweight[(offset,)] <- weight[(0, si, sj, q + packoutch * uo + po)]
                                                offset <- offset + 1
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    packedweight
                } else{
                    for(outchidx from 0 to (ll.len tileoutchs)){
                        let (outchstart, outchend) = ll.item outchidx tileoutchs
                        let unrolloutch = ll.item outchidx unrolloutchs
                        let packoutch = ll.item outchidx packoutchs
                        let unrollpackoutch = unrolloutch * packoutch
                        for(q from outchstart to outchend step unrollpackoutch){
                            for(si from 0 to weightrows){
                                for(sj from 0 to weightcols){
                                    for(uo from 0 to unrolloutch){
                                        for(po from 0 to packoutch){
                                            packedweight[(offset,)] <- weight[(0, si, sj, q + packoutch * uo + po)]
                                            offset <- offset + 1
                                        }
                                    }
                                }
                            }
                        }
                    }
                    packedweight
                }
            } else{
                for(g from 0 to groups){
                    for(outchidx from 0 to (ll.len tileoutchs)){
                        let (outchstart, outchend) = ll.item outchidx tileoutchs
                        let unrolloutch = ll.item outchidx unrolloutchs
                        let packoutch = ll.item outchidx packoutchs
                        let unrollpackoutch = unrolloutch * packoutch
                        for(q from g * groupedoutch + outchstart to g * groupedoutch + outchend step unrollpackoutch){
                            for(si from 0 to weightrows){
                                for(sj from 0 to weightcols){
                                    for(inchidx from 0 to (ll.len tileinchs)){
                                        let (inchstart, inchend) = ll.item inchidx tileinchs
                                        let unrollinch = ll.item inchidx unrollinchs
                                        let packinch = ll.item inchidx packinchs
                                        let unrollpackinch = unrollinch * packinch
                                        for(p from inchstart to inchend step unrollpackinch){
                                            for(ui from 0 to unrollinch){
                                                for(pi from 0 to packinch){
                                                    for(uo from 0 to unrolloutch){
                                                        for(po from 0 to packoutch){
                                                            packedweight[(offset,)] <- weight[(p + packinch * ui + pi, si, sj, q + packoutch * uo + po)]
                                                            offset <- offset + 1
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                packedweight
            }
        match params->weight with
            | ut.TensorI8 t     ->
                let packedweight = packing t 0i8
                ut.TensorI8(packedweight)
            | ut.TensorF16 t    ->
                let packedweight = packing t 0.f16
                ut.TensorF16(packedweight)
            | ut.TensorF32 t    ->
                let packedweight = packing t 0.f32
                ut.TensorF32(packedweight)

    (packedweight, packedbias, tileinchs, tileoutchs, packinchs, packoutchs, unrollinchs, unrolloutchs)

type TemplateParameters = {attr_params: params.Attributes, optim_params: params.Optimization, layer_params: params.Layerargs,
    input_data: ll.List<ll.List<ut.UnionTensor>>, input_dtypes: ll.List<ll.List<rtType>>, input_shapes: ll.List<ll.List<i32>>, input_scales: ll.List<ll.List<ut.UnionTensor>>, input_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    output_dtypes: ll.List<ll.List<rtType>>, output_shapes: ll.List<ll.List<i32>>, output_scales: ll.List<ll.List<ut.UnionTensor>>, output_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    input_edges: ll.List<ll.List<tuple<i32, i32>>>, output_edges: ll.List<ll.List<tuple<i32, i32>>>, ismainops: ll.List<boolean>,
    input_t_list: ll.List<rtType>, output_t_list: ll.List<rtType>}

type InternalParameters = {stride : tuple<i32, i32>, padding : tuple<i32, i32, i32, i32>, dilation : tuple<i32, i32>, groups : i32, depth_multiplier : i32,
    input_t : rtType, input_dtype : rtType, input_shape : tuple<i32, i32, i32, i32>, input_scales : ut.UnionTensor, input_zero_points : ut.UnionTensor,
    output_t : rtType, output_dtype : rtType, output_shape : tuple<i32, i32, i32, i32>, output_scales : ut.UnionTensor, output_zero_points : ut.UnionTensor,
    weight : ut.UnionTensor, weight_shape : tuple<i32, i32, i32, i32>, weight_scales : ut.UnionTensor, weight_zero_points : ut.UnionTensor, 
    bias : ut.UnionTensor, bias_scales : ut.UnionTensor, bias_zero_points : ut.UnionTensor,
    framework : string, nchw : bool, depthwise : bool, unroll : tuple<i32, i32, i32, i32>, pack : tuple<i32, i32>}

type CodeGenParameters = {
    attr_params: params.Attributes,
    isQuant: bool,
    mult: ut.UnionTensor, shift : ut.UnionTensor, packedweight : ut.UnionTensor, packedbias : ut.UnionTensor, input_zero_points : ut.UnionTensor, output_zero_points : ut.UnionTensor,
    stride : tuple<i32>, padding : tuple<i32>, dilation : tuple<i32>, groups : i32, depthwise : bool, nchw : bool,
    pack : tuple<i32>, unroll : tuple<i32>,
    input_shape : tuple<i32>, output_shape : tuple<i32>, weight_shape : tuple<i32>,
    inputpatterns : tensor<i32, 1>, inputpatternsteps : ll.List<i32>, inputpatternlens : ll.List<tensor<i32, 1>>, inputpatternoffsets : ll.List<i32>,
    // tile : (start, end) for loop generation
    // unroll : number of unrolling
    // pack : size of vector
    tileoutrows : ll.List<tuple<i32, i32>>, tileoutcols : ll.List<tuple<i32, i32>>, unrolloutrows : ll.List<i32>, unrolloutcols : ll.List<i32>,
    tileinchs : ll.List<tuple<i32, i32>>, tileoutchs : ll.List<tuple<i32, i32>>, packinchs : ll.List<i32>, packoutchs : ll.List<i32>, unrollinchs : ll.List<i32>, unrolloutchs : ll.List<i32>,
    iternamebatch : str, iternameinch : str, iternameoutch : str, iternameinputpattern : str, iternamegroup : str, iternameinputpatternsub : str,
    prefixinput : str, prefixoutput : str, prefixweight : str, prefixweightidx : str, prefixsum : str, prefixinputpattern : str, prefixinputpatternidx : str, prefixinputidx : str, prefixinputrowidx : str, prefixinputcolidx : str, prefixinputsubview : str, prefixmult : str, prefixshift : str,
    nameweight : str, namebias : str, namezeropoints : str, nameinputpattern : str, namebatchinput : str, namebatchoutput : str, nameinput : str, nameoutput : str, namemult : str, nameshift : str, namepad : str,
    setvarsimpls : ll.List, premicroopsimpls: ll.List, postmicroopsimpls : ll.List, inputpadopsimpls: ll.List, outputpadopsimpls: ll.List, loopopsimpls : ll.List,
}

let initCodeGen templateparams params = 
    let (setvarsimpls, premicroopsimpls, postmicroopsimpls, inputpadopsimpls, outputpadopsimpls, loopopsimpls) = fsn.init (templateparams->layer_params) (templateparams->input_data) (templateparams->input_dtypes) (templateparams->input_shapes) (templateparams->input_scales) (templateparams->input_zero_points) (templateparams->output_dtypes) (templateparams->output_shapes) (templateparams->output_scales) (templateparams->output_zero_points) (templateparams->input_edges) (templateparams->output_edges) (templateparams->ismainops)

    let (mult, shift) = prepareMultShift params
    let (inputpatterns, inputpatternsteps, inputpatternlens, inputpatternoffsets, tileoutrows, tileoutcols, unrolloutrows, unrolloutcols) = prepareInputPattern params inputpadopsimpls outputpadopsimpls
    let (packedweight, packedbias, tileinchs, tileoutchs, packinchs, packoutchs, unrollinchs, unrolloutchs) = prepareWeightAndBias params


    let codeGenParameters = if(params->depthwise){
            let iternameinch = if(params->groups == 1){"q"} else{"p"}
            CodeGenParameters(
                templateparams->attr_params,
                ut.isQuant (params->weight),
                mult, shift, packedweight, packedbias, params->input_zero_points, params->output_zero_points,
                params->stride, params->padding, params->dilation, params->groups, params->depthwise, params->nchw,
                params->pack, params->unroll, params->input_shape, params->output_shape, params->weight_shape,
                inputpatterns, inputpatternsteps, inputpatternlens,inputpatternoffsets, tileoutrows, tileoutcols, unrolloutrows, unrolloutcols,
                tileinchs, tileoutchs, packinchs, packoutchs, unrollinchs, unrolloutchs,
                "b", iternameinch, "q", "ip", "g", "ips", "i", "o", "w", "widx", "acc", "ip", "ipidx", "iidx", "irowidx", "icolidx", "isub", "m", "sh", "weight", "bias", "zero", "inputpattern", "batchinput", "batchoutput", "input", "output", "mult", "shift", "pad",
                setvarsimpls, premicroopsimpls, postmicroopsimpls, inputpadopsimpls, outputpadopsimpls, loopopsimpls,
            )
        } else{
            CodeGenParameters(
                templateparams->attr_params,
                ut.isQuant (params->weight),
                mult, shift, packedweight, packedbias, params->input_zero_points, params->output_zero_points,
                params->stride, params->padding, params->dilation, params->groups, params->depthwise, params->nchw,
                params->pack, params->unroll, params->input_shape, params->output_shape, params->weight_shape,
                inputpatterns, inputpatternsteps, inputpatternlens,inputpatternoffsets, tileoutrows, tileoutcols, unrolloutrows, unrolloutcols,
                tileinchs, tileoutchs, packinchs, packoutchs, unrollinchs, unrolloutchs,
                "b", "p", "q", "ip", "g", "ips", "i", "o", "w", "widx", "acc", "ip", "ipidx", "iidx", "irowidx", "icolidx", "isub", "m", "sh", "weight", "bias", "zero", "inputpattern", "batchinput", "batchoutput", "input", "output", "mult", "shift", "pad",
                setvarsimpls, premicroopsimpls, postmicroopsimpls, inputpadopsimpls, outputpadopsimpls, loopopsimpls,
            )
        }

    codeGenParameters

///////////////////////////////////////////////////////
///////////     runtime expr gen codes     ////////////
///////////////////////////////////////////////////////
type IndexesKeys =
    | Inputpattern
    | Outrow
    | Outcol
    | Inch
    | Outch
    | Weightrow
    | Weightcol

    
type Indexes = {inputpattern : i32, inch : i32, outch : i32}

let updateIndexes idxs key val = 
    match key with
        | Inputpattern   -> Indexes(val, idxs->inch, idxs->outch)
        | Inch           -> Indexes(idxs->inputpattern, val, idxs->outch)
        | Outch          -> Indexes(idxs->inputpattern, idxs->inch, val)

type UnrollIndexes = {outrow : i32, outcol : i32, inch : i32, outch : i32, weightrow : i32, weightcol : i32}

let updateUnrollIndexes idxs key val = 
    match key with
        | Outrow    -> UnrollIndexes(val, idxs->outcol, idxs->inch, idxs->outch, idxs->weightrow, idxs->weightcol)
        | Outcol    -> UnrollIndexes(idxs->outrow, val, idxs->inch, idxs->outch, idxs->weightrow, idxs->weightcol)
        | Inch      -> UnrollIndexes(idxs->outrow, idxs->outcol, val, idxs->outch, idxs->weightrow, idxs->weightcol)
        | Outch     -> UnrollIndexes(idxs->outrow, idxs->outcol, idxs->inch, val, idxs->weightrow, idxs->weightcol)
        | Weightrow -> UnrollIndexes(idxs->outrow, idxs->outcol, idxs->inch, idxs->outch, val, idxs->weightcol)
        | Weightcol -> UnrollIndexes(idxs->outrow, idxs->outcol, idxs->inch, idxs->outch, idxs->weightrow, val)

type Optree<a> =
    | End of a
    | Op of a * Optree<a>
    | Block of a * Optree<a> * Optree<a>

let getop optree = 
    match optree with
    | End(op)                       -> (op, op)
    | Op(op, nextop)                -> (op, nextop)
    | Block(op, innerop, nextop)    -> (op, Op(innerop, nextop))

let getblock optree =
    let (innerops, nextops) = getop optree
    let (innerop, inneropsnew) = getop innerops
    let (nextop, nextopsnew) = getop nextops
    (innerop, inneropsnew, nextop, nextopsnew)

type VarNames = 
    | Input
    | Weight
    | Weightidx
    | Bias
    | Output
    | Sum
    | Inputpattern
    | Inputpatternidx
    | Inputidx
    | Inputrowidx
    | Inputcolidx
    | Inputsubview
    | Mult
    | Shift

let getVarName target uidxs params idxs = 
    match target with
        | Input             -> params->prefixinput + toStr(ll.item (idxs->inch) (params->packinchs)) + "x" + ut.dtypeStr(params->packedweight) + "u" + toStr(uidxs->outrow) + toStr(uidxs->outcol) + toStr(uidxs->inch)
        | Weight            -> params->prefixweight + toStr(ll.item (idxs->outch) (params->packoutchs)) + "x" + ut.dtypeStr(params->packedweight)
        // | Weight            -> params->prefixweight + toStr(ll.item (idxs->outch) (params->packoutchs)) + "x" + ut.dtypeStr(params->packedweight) + "u" + toStr(uidxs->inch) + toStr(uidxs->outch)
        | Weightidx         -> params->prefixweightidx
        | Sum               -> params->prefixsum + toStr(ll.item (idxs->outch) (params->packoutchs)) + "x" + ut.dtypeStr(params->packedbias) + "u" + toStr(uidxs->outrow) + toStr(uidxs->outcol) + toStr(uidxs->outch) 
        | Inputpattern      -> params->prefixinputpattern + "1u" + toStr(uidxs->outrow) + toStr(uidxs->outcol) + toStr(uidxs->weightrow) + toStr(uidxs->weightcol)
        | Inputpatternidx   -> params->prefixinputpatternidx + "1u" + toStr(uidxs->outrow) + toStr(uidxs->outcol) // + toStr(uidxs->weightrow) + toStr(uidxs->weightcol)
        | Inputidx          -> params->prefixinputidx + "1u" + toStr(uidxs->outrow) + toStr(uidxs->outcol) // + toStr(uidxs->weightrow) + toStr(uidxs->weightcol)
        | Inputrowidx          -> params->prefixinputrowidx + "1u" + toStr(uidxs->outrow) + toStr(uidxs->outcol) // + toStr(uidxs->weightrow) + toStr(uidxs->weightcol)
        | Inputcolidx          -> params->prefixinputcolidx + "1u" + toStr(uidxs->outrow) + toStr(uidxs->outcol) // + toStr(uidxs->weightrow) + toStr(uidxs->weightcol)
        | Inputsubview      -> params->prefixinputsubview + toStr(params->input_shape[|3|])+ "x" + ut.dtypeStr(params->packedweight) + "u" + toStr(uidxs->outrow) + toStr(uidxs->outcol)
        | Mult              -> params->prefixmult + toStr(ll.item (idxs->outch) (params->packoutchs)) + "x" + ut.dtypeStr(params->mult) + "u" + toStr(uidxs->outch) 
        | Shift             -> params->prefixshift + toStr(ll.item (idxs->outch) (params->packoutchs)) + "x" + ut.dtypeStr(params->shift) + "u" + toStr(uidxs->outch) 

let getUnrolls params idxs =
    (ll.item (idxs->inputpattern) (params->unrolloutrows), ll.item (idxs->inputpattern) (params->unrolloutcols), ll.item (idxs->inch) (params->unrollinchs), ll.item (idxs->outch) (params->unrolloutchs))

let genRuntimeCode params idxs ops =
    match ops with
    | End(op)                       -> op params idxs ops
    | Op(op, nextop)                -> op params idxs nextop
    | Block(op, innerop, nextop)    -> op params idxs (Op(innerop, nextop))

let endExpr params idxs ops =
    !{
        // let ${"debugMessageEnd"} = ${toStr(idxs)}
        _end_
    }

let zeroExpr params idxs ops =
    !{0}

let setBatchInputOutputExpr params idxs ops = 
    let (nextop, opsnew) = getop(ops)
    let namebatchinput = params->namebatchinput
    let namebatchoutput = params->namebatchoutput
    let (batch, inrows, incols, inch) = params->input_shape
    let (_, outrows, outcols, outch) = params->output_shape
    // !{
    //     let mut ${namebatchoutput} = reshapeTo((${batch * outrows * outcols * outch},), &outputs[|0|])
    //     let mut ${namebatchinput} = reshapeTo((${(batch + 1) * inrows * incols * inch},), inputs[|0|])
    //     ${nextop params idxs opsnew}
    // }
    let loopopsimpls = params->loopopsimpls
    let outputnames = ["outputs"]
    let loopopsexpr = fsn.genLoopOpsExpr loopopsimpls outputnames

    let setvarsimpls = params->setvarsimpls
    let batchinputnames = [namebatchinput; ""; ""]
    let batchoutputnames = [namebatchoutput]
    let inputshapes = [ [(batch + 1) * inrows * incols * inch]; [0]; [0] ]
    let outputshapes = [ [batch * outrows * outcols * outch] ]
    let ismutinputs = [true; false; false]

    loopopsexpr (fsn.genSetVarsExpr setvarsimpls batchinputnames batchoutputnames inputshapes outputshapes ismutinputs (nextop params idxs opsnew))

let setWeightExpr params idxs ops =
    let (nextop, opsnew) = getop(ops)
    let nameweight = params->nameweight
    let weight = params->packedweight
    
    !{
        let ${nameweight} = ${ut.toRtTensor weight}
        ${nextop params idxs opsnew}
    }

let setBiasExpr params idxs ops =
    let (nextop, opsnew) = getop(ops)
    let namebias = params->namebias
    let bias = params->packedbias
    match bias with 
        | ut.EMPTY  ->
            !{
                ${nextop params idxs opsnew}
            }

        | _         ->
            !{
                let ${namebias} = ${ut.toRtTensor bias}
                ${nextop params idxs opsnew}
            }

let setZeropointsExpr params idxs ops =
    let (nextop, opsnew) = getop(ops)
    let namezeropoints = params->namezeropoints
    let zero = params->output_zero_points
    if(params->isQuant){
        !{
            let ${namezeropoints} = ${ut.toRtTensor zero}
            ${nextop params idxs opsnew}
        }
    } else{
        !{
            ${nextop params idxs opsnew}
        }
    }

let setInputpatternExpr params idxs ops =
    let (nextop, opsnew) = getop(ops)
    let nameinputpattern = params->nameinputpattern
    let inputpatterns = params->inputpatterns

    !{
        let ${nameinputpattern} = ${(inputpatterns)}
        ${nextop params idxs opsnew}
    }

let setMultShiftExpr params idxs ops = 
    let (nextop, opsnew) = getop(ops)
    let namemult = params->namemult
    let nameshift = params->nameshift

    if(params->isQuant){
        !{
            let ${namemult} = ${ut.toRtTensor (params->mult)}
            let ${nameshift} = ${ut.toRtTensor (params->shift)}
            ${nextop params idxs opsnew}
        }
    } else{
        !{
            ${nextop params idxs opsnew}
        }
    }

// let setFusedVarsExpr params idxs ops =
//     let (nextop, opsnew) = getop(ops)
//     let setvarsimpls = params->setvarsimpls
//     let inputnames = [params->batchinputname, "", ""]
//     let outputnames = [params->batchoutput]
//     let inputshapes = 
//     fsn.genSetVarsExpr setvarsimpls ([-1]) (nextop params idxs opsnew)

let setWeightidxExpr params idxs ops =
    let (nextop, opsnew) = getop(ops)
    let uidxs = UnrollIndexes(0, 0, 0, 0, 0, 0)
    let nameweightidx = getVarName Weightidx uidxs params idxs

    !{
        let mut ${nameweightidx} = 0
        ${nextop params idxs opsnew}
    }

let setPadExpr params idxs ops = 
    let (nextop, opsnew) = getop(ops)
    let namepad = params->namepad
    let namebatchinput = params->namebatchinput
    let (batch, inrows, incols, inch) = params->input_shape
    let inputpadopsimpls = params->inputpadopsimpls
    let (_, input_shape) = fsn.padOps inputpadopsimpls ([[0; 0]; [0;0]; [0;0]; [0; 0]]) ([batch; inrows; incols; inch])
    // let padstart = batch * inrows * incols * inch
    let padstart = (ll.item 0 input_shape) * (ll.item 1 input_shape) * (ll.item 2 input_shape) * (ll.item 3 input_shape)
    let valpad = 
        match params->packedweight with
            | ut.TensorI8 t     ->
                match params->input_zero_points with
                    | ut.TensorI32 t    -> !{${cast<i8>(t[(0,)])}}
                    | _                 -> except("An error occured while setting padExpr")
            | ut.TensorF16 t    ->
                !{0.f16}
            | ut.TensorF32 t    ->
                !{0.f32}
    !{
        // let mut ${namebatchinput} = reshapeTo((${(batch + 1) * inrows * incols * inch},), inputs[|0|]) // for layer_ct
        ${namebatchinput}[(${padstart}:${padstart + inch}:1,)] <- tensor((${inch},), ${valpad})
        ${nextop params idxs opsnew}
    }

let setIternameInput params idxs ops = 
    if(params->depthwise){
        let (nextop, opsnew) = getop(ops)
        let iternameinch = params->iternameinch
        let iternameoutch = params->iternameoutch
        let groups = params->groups

        !{
            let ${iternameinch} = ${iternameoutch} / ${groups}
            ${nextop params idxs opsnew}
        }
    } else{
        except("setiternameinput error")
    }

// // channel loop expression
let groupLoopExpr params idxs ops =
    let (innerop, inneropsnew, nextop, nextopsnew) = getblock ops
    !{
        for(${params->iternamegroup} from 0 to ${params->groups}){
            ${innerop params idxs inneropsnew}
        }
        ${nextop params idxs nextopsnew}
    }

let weightLoopExpr params idxs ops =
    let (innerop, inneropsnew, nextop, nextopsnew) = getblock ops
    let (_, weightrows, weightcols, _) = params->weight_shape
    !{
        for(${params->iternameinputpatternsub} from 0 to ${weightrows * weightcols}){
            ${innerop params idxs inneropsnew}
        }
        ${nextop params idxs nextopsnew}
    }

// Tiled input channel loop expression
let tiledInputPatternLoopExpr params idxs ops = 
    let rec genTiledInputPatternLoopExpr index params idxs ops =
        let (innerop, inneropsnew, nextop, nextopsnew) = getblock ops
        if (index == 4){
            nextop params idxs nextopsnew
        } else{
            let itername = params->iternameinputpattern
            let inputpatternsteps = params->inputpatternsteps
            let inputpatternlens = params->inputpatternlens
            let inputpatternstep = ll.item index inputpatternsteps
            let inputpatternlen = ll.item index inputpatternlens
            let offset = ll.item (idxs->inputpattern) (params->inputpatternoffsets)
            let idxsnew = updateIndexes idxs Inputpattern (index + 1)

            if (inputpatternlen > 0){
                !{
                    attr [ Parallel: params->attr_params->num_threads > 1 ]
                    for (${itername} from ${offset} to ${offset + inputpatternlen} step ${inputpatternstep}){
                        ${innerop params idxs inneropsnew}
                    }
                    ${genTiledInputPatternLoopExpr (index + 1) params idxsnew ops}
                }
            } else{
                !{
                    ${genTiledInputPatternLoopExpr (index + 1) params idxsnew ops}
                }
            }
        }
    
    genTiledInputPatternLoopExpr 0 params idxs ops

/// Tiled channel loop expression
// generate tiled input or output channel loop
// target: 0 (input), 1 (output)
// params->iternameinchs/outchs : string, itername
// params->packinchs/outchs : tuple<i32>, packing parameters 
// params->unrollinchs/outchs : tuple<i32>, unrolling parameters
// params->loopinchs/outchs : tuple<tuple<i32>>, loop parameters, (start, end)
// number of element in pack, unroll and loop should be same
// idxs->inchidx/outchidx : i32, index to select parameter
let rec genTiledChannelLoopExpr index target params idxs ops = 
    let (innerop, inneropsnew, nextop, nextopsnew) = getblock ops
    let tilelen = if(target == 0){ll.len (params->tileinchs)} else{ll.len (params->tileoutchs)}
    let groups = params->groups
    let iternamegroup = params->iternamegroup
    if (index == tilelen){
        let idxsnew = if(target == 0){
            updateIndexes idxs Inch 0
        } else{
            updateIndexes idxs Outch 0
        }
        nextop params idxsnew nextopsnew
    } else{
        let (idxsnew, pack, unroll, groupedch, (start, end), itername) = if(target == 0){
                let subidx = idxs->inch
                let idxsnew = updateIndexes idxs Inch (index + 1)
                let (_, _, _, inch) = params->input_shape
                (idxsnew, ll.item subidx (params->packinchs), ll.item subidx (params->unrollinchs), inch / groups, ll.item subidx (params->tileinchs), params->iternameinch)
            } else{
                let subidx = idxs->outch
                let idxsnew = updateIndexes idxs Outch (index + 1)
                let (_, _, _, outch) = params->output_shape
                (idxsnew, ll.item subidx (params->packoutchs), ll.item subidx (params->unrolloutchs), outch / groups, ll.item subidx (params->tileoutchs), params->iternameoutch)
            }
        if(params->depthwise){
            !{
                for(${itername} from ${start} to ${end} step ${pack * unroll}){
                    ${innerop params idxs inneropsnew}
                }
                ${genTiledChannelLoopExpr (index + 1) target params idxsnew ops}
            }
        } else{
            !{
                for(${itername} from ${groupedch} * ${iternamegroup} + ${start} to ${groupedch} * ${iternamegroup} + ${end} step ${pack * unroll}){
                    ${innerop params idxs inneropsnew}
                }
                ${genTiledChannelLoopExpr (index + 1) target params idxsnew ops}
            }
        }
    }

let tiledInputChannelLoopExpr params idxs ops = 
    genTiledChannelLoopExpr 0 0 params idxs ops

let tiledOutputChannelLoopExpr params idxs ops = 
    genTiledChannelLoopExpr 0 1 params idxs ops

let batchLoopExpr params idxs ops = 
    let (innerop, inneropsnew, nextop, nextopsnew) = getblock ops
    let itername = params->iternamebatch
    let start = 0i32
    let (end, _, _, _) = params->input_shape
    let (nextop, opsnew) = getop ops
    let (batch, inh, inw, inch) = params->input_shape
    let (_, outh, outw, outch) = params->output_shape
    let inputoffset = inh * inw * inch
    let outputoffset = outh * outw * outch
    let batchinputname = params->namebatchinput
    let batchoutputname = params->namebatchoutput
    let inputname = params->nameinput
    let outputname = params->nameoutput
    let iternamebatch = params->iternamebatch
    if (batch > 1){
        !{
            for(${itername} from ${start} to ${end} step 1i){
                let mut ${inputname} = &${batchinputname}[(${iternamebatch} * ${inh * inw * inch}:${(batch + 1) * inh * inw * inch}:1,)]
                let mut ${outputname} = &${batchoutputname}[(${iternamebatch} * ${outputoffset}:(${iternamebatch} + 1) * ${outputoffset}:1,)]
                ${innerop params idxs inneropsnew}
            }
            ${nextop params idxs nextopsnew}
        }
    } else{
        !{
            let mut ${inputname} = &${batchinputname}
            let mut ${outputname} = &${batchoutputname}
            let _ = (
                ${innerop params idxs inneropsnew}
            )

            ${nextop params idxs nextopsnew}
        }
    }

// Load sum expression
let unrolledLoadSumExpr params idxs ops = 
    let unrollidxs = UnrollIndexes(0, 0, 0, 0, 0, 0)
    let (unrollrow, unrollcol, unrollinch, unrolloutch) = getUnrolls params idxs
    let packoutch = ll.item (idxs->outch) (params->packoutchs)
    let bias = params->packedbias

    let rec genExpr index uidxs =
        let sumname = getVarName Sum uidxs params idxs
        let (rowidx, colidx, inchidx, outchidx) = (uidxs->outrow, uidxs->outcol, uidxs->inch, uidxs->outch)
        if (index == unrollrow * unrollcol * unrolloutch) {
            let (nextop, opsnew) = getop ops
            nextop params idxs opsnew
        } else{
            let (rowidxnew, colidxnew, outchidxnew) =
                if ((colidx + 1 == unrollcol) && (rowidx + 1 == unrollrow)){
                    (0, 0, outchidx + 1)
                } else if (colidx + 1 == unrollcol) {
                    (rowidx + 1, 0, outchidx)
                } else{
                    (rowidx, colidx + 1, outchidx)
                }
            
            let sumname00 = getVarName Sum (UnrollIndexes(0, 0, inchidx, outchidx, 0, 0)) params idxs
            let expr = 
                match bias with
                    | ut.EMPTY  ->
                        let val =
                            match (params->packedweight) with
                                | ut.TensorI8 t     -> !{0i32}
                                | ut.TensorF16 t    -> !{0.f16}
                                | ut.TensorF32 t    -> !{0.f32}
                        !{tensor((${packoutch},), ${val})}
                    | _         ->
                        !{${params->namebias}[(${params->iternameoutch} + ${outchidx * packoutch}:${params->iternameoutch} + ${(outchidx + 1) * packoutch}:1,)]}

            if(rowidx == 0 && colidx == 0){
                !{
                    let mut ${sumname} = ${expr}
                    ${genExpr (index + 1) (UnrollIndexes(rowidxnew, colidxnew, inchidx, outchidxnew, 0, 0))}
                }
            } else{
                !{
                    let mut ${sumname} = ${sumname00}
                    ${genExpr (index + 1) (UnrollIndexes(rowidxnew, colidxnew, inchidx, outchidxnew, 0, 0))}
                }
            }

        }
    
    genExpr 0 unrollidxs

let unrolledSetInputpatternidxExpr params idxs ops = 
    let unrollidxs = UnrollIndexes(0, 0, 0, 0, 0, 0)
    let (unrollrow, unrollcol, unrollinch, unrolloutch) = getUnrolls params idxs
    let (_, weightrows, weightcols, _) = params->weight_shape
    let offset = ll.item (idxs->inputpattern) (params->inputpatternoffsets)

    let rec genExpr index uidxs =
        let ipidxname = getVarName Inputpatternidx uidxs params idxs
        let (rowidx, colidx, inchidx, outchidx) = (uidxs->outrow, uidxs->outcol, uidxs->inch, uidxs->outch)
        if (index == unrollrow * unrollcol) {
            let (nextop, opsnew) = getop ops
            nextop params idxs opsnew
        } else{
            let (rowidxnew, colidxnew) =
                if ((colidx + 1 == unrollcol)){
                    (rowidx + 1, 0)
                } else{
                    (rowidx, colidx + 1)
                }
            !{
                let mut ${ipidxname} = ${params->iternameinputpattern} + ${(weightrows * weightcols + 1) * colidx + (weightrows * weightcols + 1) * unrollcol * rowidx}
                ${genExpr (index + 1) (UnrollIndexes(rowidxnew, colidxnew, 0, 0, 0, 0))}
            }
        }
    
    genExpr 0 unrollidxs

let unrolledUpdateInputpatternidxExpr params idxs ops = 
    let unrollidxs = UnrollIndexes(0, 0, 0, 0, 0, 0)
    let (unrollrow, unrollcol, unrollinch, unrolloutch) = getUnrolls params idxs
    let (_, weightrows, weightcols, _) = params->weight_shape
    let offset = ll.item (idxs->inputpattern) (params->inputpatternoffsets)
    let packinch = ll.item (idxs->inch) (params->packinchs)

    let rec genExpr index uidxs =
        let ipidxname = getVarName Inputpatternidx uidxs params idxs
        let (rowidx, colidx, inchidx, outchidx) = (uidxs->outrow, uidxs->outcol, uidxs->inch, uidxs->outch)
        if (index == unrollrow * unrollcol) {
            let (nextop, opsnew) = getop ops
            nextop params idxs opsnew
        } else{
            let (rowidxnew, colidxnew) =
                if ((colidx + 1 == unrollcol)){
                    (rowidx + 1, 0)
                } else{
                    (rowidx, colidx + 1)
                }
            !{
                ${ipidxname} <- ${ipidxname} + 1
                ${genExpr (index + 1) (UnrollIndexes(rowidxnew, colidxnew, 0, 0, 0, 0))}
            }
        }
    
    genExpr 0 unrollidxs

let unrolledInputSubviewExpr params idxs ops =
    let unrollidxs = UnrollIndexes(0, 0, 0, 0, 0, 0)
    let (unrollrow, unrollcol, unrollinch, unrolloutch) = getUnrolls params idxs
    let (_, weightrows, weightcols, _) = params->weight_shape
    let offset = ll.item (idxs->inputpattern) (params->inputpatternoffsets)
    let (inchstart, inchend) = ll.item (idxs->inch) (params->tileinchs)
    let (outchstart, outchend) = ll.item (idxs->outch) (params->tileoutchs)
    let (b, h, w, inch) = params->input_shape
    let inputlength = h * w * inch
    let packinch = ll.item (idxs->inch) (params->packinchs)

    let rec genExpr index uidxs =
        let ipidxname = getVarName Inputpatternidx uidxs params idxs
        let iidxname = getVarName Inputidx uidxs params idxs
        let inputpatternname = params->nameinputpattern
        let isubviewname = getVarName Inputsubview uidxs params idxs
        let padname = params->namepad
        let inputname = params->nameinput
        let (rowidx, colidx, inchidx, outchidx) = (uidxs->outrow, uidxs->outcol, uidxs->inch, uidxs->outch)
        if (index == unrollrow * unrollcol) {
            let (nextop, opsnew) = getop ops
            nextop params idxs opsnew
        } else{
            let (rowidxnew, colidxnew) =
                if ((colidx + 1 == unrollcol)){
                    (rowidx + 1, 0)
                } else{
                    (rowidx, colidx + 1)
                }
            let iidxexpr =
                if(b > 1){
                    !{__min(${b * h * w * inch}, ${inputpatternname}[(${ipidxname},)])}
                } else{
                    !{${inputpatternname}[(${ipidxname},)]}
                }
            
            let subviewexpr = 
                if(params->depthwise){
                    // !{&${inpujtname}[(${iidxname}:${iidxname} + ${packinch * unrollinch}:1,)]}
                    !{&${inputname}[(${iidxname}:${iidxname} + ${outchend}:1,)]}
                } else{
                    !{${inputname}[(${iidxname}:${iidxname} + ${inch}:1,)]}
                }
            
            !{
                let ${iidxname} = ${iidxexpr}
                let mut ${isubviewname} = ${subviewexpr} // speed check
                ${genExpr (index + 1) (UnrollIndexes(rowidxnew, colidxnew, 0, 0, 0, 0))}
            }
        }
    
    genExpr 0 unrollidxs

fun vmlal(sum : tensor<i32, 1>, i : tensor<i16, 1>, w : tensor<i16, 1>) -> i32 {
    sum <- sum + cast<i32>(i * w)
    _end_
}

// unrolld load input, load weight, and fma
// unrolled along outch, inch{    
//   load weight
//   unrolled along outrows, outcols{
//     loadinput
//     fma   
//   }
// }
let unrolledLoadInputWeightAndFMAExpr params idxs ops = 
    let unrollidxs = UnrollIndexes(0, 0, 0, 0, 0, 0)
    let nameinput = params->nameinput
    let nameweight = params->nameweight
    let nameinputpattern = params->nameinputpattern
    let (unrollrow, unrollcol, unrollinch, unrolloutch) = getUnrolls params idxs
    let packinch = ll.item (idxs->inch) (params->packinchs)
    let packoutch = ll.item (idxs->outch) (params->packoutchs)
    let tileoutchslen = ll.len (params->tileoutchs)
    let tileinchslen = ll.len (params->tileinchs)
    let (_, weightrows, weightcols, _) = params->weight_shape
    let inch = params->input_shape[|3|]
    let outch = params->output_shape[|3|]
    let groups = params->groups
    let groupedinch, groupedoutch = inch / groups, outch / groups
    let premicroopsimpls = params->premicroopsimpls

    let loadInputExpr uidxs params idxs nextop = 
        let packinch = 
            if(params->depthwise){
                ll.item (idxs->outch) (params->packoutchs)
            } else{
                ll.item (idxs->inch) (params->packinchs)
            }

        let inchOffset uidxs =
            let (rowidx, colidx, inchidx, outchidx, wrowidx, wcolidx) = (uidxs->outrow, uidxs->outcol, uidxs->inch, uidxs->outch, uidxs->weightrow, uidxs->weightcol)
            !{${params->iternameinch} + ${inchidx * packinch}}

        let inchidx = uidxs->inch
        let outchidx = uidxs->outch
        let inchsubidx = uidxs->weightrow

        let inputpatternidx = getVarName Inputpatternidx uidxs params idxs
        let inputpattern = getVarName Inputpattern uidxs params idxs
        let inputsubview = getVarName Inputsubview uidxs params idxs
        let input = getVarName Input uidxs params idxs
        let iidxname = getVarName Inputidx uidxs params idxs
        let iidxname2 = iidxname + toStr(outchidx)

        let vectorsize = if(params->depthwise){ll.item (idxs->outch) (params->packoutchs)} else{ll.item (idxs->inch) (params->packinchs)}
        let vectordtype =
            match (params->packedweight) with
                | ut.TensorF32 x -> rtType(f32)
                | ut.TensorF16 x -> rtType(f16)
                | ut.TensorI8 x -> rtType(i32)
        let fusedExpr = fsn.genMicroOpsExpr premicroopsimpls input input ([iidxname2]) vectorsize vectordtype

        let genExpr expr =
            if(params->isQuant){
                !{
                    // let ${iidxname2} = ${iidxname} + ${inchOffset uidxs} // speed check
                    let mut ${input} = cast<i16>(${expr})
                    ${fusedExpr nextop}
                }
            } else{
                !{
                    // let ${iidxname2} = ${iidxname} + ${inchOffset uidxs} // speed check
                    let mut ${input} = ${expr}
                    ${fusedExpr nextop}
                }
            }

        if(params->depthwise){
            if(groups == 1){
                let expr = !{${inputsubview}[(${inchOffset uidxs}:${inchOffset uidxs} + ${packinch}:1,)]} // speed check
                // let expr = !{${params->nameinput}[(${iidxname2}:${iidxname2} + ${packinch}:1,)]} // speed check
                // let expr = !{${params->nameinput}[(${iidxname} + ${inchOffset uidxs}:${iidxname} + ${inchOffset uidxs} + ${packinch}:1,)]}
                genExpr expr
            } else{
                let expr = !{${inputsubview}[(${inchOffset uidxs}:${inchOffset uidxs} + 1:1,)]} // speed check
                // let expr = !{${params->nameinput}[(${iidxname2}:${iidxname2} + 1:1,)]} // speed check
                if((packoutch * outchidx) % groups == 0){
                    genExpr expr
                } else{
                    !{
                        ${fusedExpr nextop}
                    }
                }
            }
        } else{
            if(outchidx == 0 && inchsubidx == 0){
                let expr = !{${inputsubview}[(${inchOffset uidxs}:${inchOffset uidxs} + ${packinch}:1,)]} // speed check
                // let expr = !{${params->nameinput}[(${iidxname2}:${iidxname2} + ${packinch}:1,)]} // speed check
                genExpr expr
            } else{
                !{
                    ${nextop}
                }
            }
        }

    let loadWeightExpr uidxs uidxs_old params idxs nextop = 
        let packoutch = ll.item (idxs->outch) (params->packoutchs)

        let weight = getVarName Weight uidxs params idxs
        let weightidx = getVarName Weightidx uidxs params idxs

        let rowidx, colidx, inchidx, outchidx, inchsubidx = uidxs->outrow, uidxs->outcol, uidxs->inch, uidxs->outch, uidxs->weightrow
        let rowidx_old, colidx_old, inchidx_old, outchidx_old = uidxs_old->outrow, uidxs_old->outcol, uidxs_old->inch, uidxs_old->outch
        // let updateflag = ((rowidx == 0) && (colidx == 0)) || (inchidx != inchidx_old) || (outchidx != outchidx_old)
        let updateflag = ((rowidx == 0) && (colidx == 0)) || (outchidx != outchidx_old)

        if((rowidx == 0) && (colidx == 0) && (inchidx == 0) && (outchidx == 0) && (inchsubidx == 0)){
            if(params->isQuant){
                !{
                    let mut ${weight} = cast<i16>(${params->nameweight}[(${weightidx}:${weightidx} + ${packoutch}:1,)])
                    ${weightidx} <- ${weightidx} + ${packoutch}
                    ${nextop}
                }
            } else{
                !{
                    let mut ${weight} = ${params->nameweight}[(${weightidx}:${weightidx} + ${packoutch}:1,)]
                    ${weightidx} <- ${weightidx} + ${packoutch}
                    ${nextop}
                }
            }
        } else if(updateflag){
            if(params->isQuant){
                !{
                    ${weight} <- cast<i16>(${params->nameweight}[(${weightidx}:${weightidx} + ${packoutch}:1,)])
                    ${weightidx} <- ${weightidx} + ${packoutch}
                    ${nextop}
                }
            } else{
                !{
                    ${weight} <- ${params->nameweight}[(${weightidx}:${weightidx} + ${packoutch}:1,)]
                    ${weightidx} <- ${weightidx} + ${packoutch}
                    ${nextop}
                }
            }
        } else{
            !{
                ${nextop}
            }
        }

    let executeFMAExpr uidxs params idxs nextop =
        let packinch = ll.item (idxs->inch) (params->packinchs)

        let input = getVarName Input uidxs params idxs
        let weight = getVarName Weight uidxs params idxs
        let sum = getVarName Sum uidxs params idxs
        let inchsubidx = uidxs->weightrow

        if(params->depthwise){
            if(params->isQuant){
                !{
                    // let _ = vmlal(${sum}, ${input}, ${weight})
                    ${sum} <- ${sum} + cast<i32>(${input} * ${weight})
                    ${nextop}
                }
            } else{
                !{
                    // let _ = vmlal(${sum}, ${input}, ${weight})
                    ${sum} <- ${sum} + ${input} * ${weight}
                    ${nextop}
                }
            }
        } else{
            if(packinch == 1){
                if(params->isQuant){
                    !{
                        // let _ = vmlal(${sum}, ${input}, ${weight})
                        ${sum} <- ${sum} + cast<i32>(${input} * ${weight})
                        ${nextop}
                    }
                } else{
                    !{
                        // let _ = vmlal(${sum}, ${input}, ${weight})
                        ${sum} <- ${sum} + ${input} * ${weight}
                        ${nextop}
                    }
                }
            } else{
                if(params->isQuant){
                    !{
                        // let _ = vmlal(${sum}, ${input}[(${inchsubidx}:${inchsubidx}+1:1,)], ${weight})
                        ${sum} <- ${sum} + cast<i32>(${input}[(${inchsubidx}:${inchsubidx + 1}:1,)] * ${weight})
                        ${nextop}
                    }
                } else{
                    !{
                        // let _ = vmlal(${sum}, ${input}[(${inchsubidx}:${inchsubidx}+1:1,)], ${weight})
                        ${sum} <- ${sum} + ${input}[(${inchsubidx}:${inchsubidx + 1}:1,)] * ${weight}
                        ${nextop}
                    }
                }
            }
        }



    let rec genExpr index uidxs uidxs_old = 
        let (rowidx, colidx, inchidx, outchidx, inchsubidx, wcolidx) = (uidxs->outrow, uidxs->outcol, uidxs->inch, uidxs->outch, uidxs->weightrow, uidxs->weightcol)
        let stopflag = if(params->depthwise){unrollrow * unrollcol * unrolloutch} else{unrollrow * unrollcol * unrollinch * unrolloutch * packinch}
        if(index == stopflag){
            let (nextop, opsnew) = getop ops
            let idxsnew = updateIndexes idxs Inch 0
            nextop params idxsnew opsnew
        } else{
            let (rowidxnew, colidxnew, inchidxnew, outchidxnew, inchsubidxnew, wcolidxnew) =
                if(params->depthwise){
                    if(params->groups == 1){
                        if ((colidx + 1 == unrollcol) && (rowidx + 1 == unrollrow)) {
                            (0, 0, outchidx + 1, outchidx + 1, 0, 0)
                        } else if (colidx + 1 == unrollcol){
                            (rowidx + 1, 0, outchidx, outchidx, 0, 0)
                        } else {
                            (rowidx, colidx + 1, outchidx, outchidx, 0, 0)
                        }
                    } else{
                        if ((colidx + 1 == unrollcol) && (rowidx + 1 == unrollrow)) {
                            (0, 0, (packoutch * (outchidx + 1)) / groups, outchidx + 1, 0, 0)
                        } else if (colidx + 1 == unrollcol){
                            (rowidx + 1, 0, (packoutch * outchidx) / groups, outchidx, 0, 0)
                        } else {
                            (rowidx, colidx + 1, (packoutch * outchidx) / groups, outchidx, 0, 0)
                        }
                    }
                } else{
                    // if ((colidx + 1 == unrollcol) && (rowidx + 1 == unrollrow) && (outchidx + 1 == unrolloutch)){
                    //     (0, 0, inchidx + 1, 0, 0, 0)
                    // } else if ((colidx + 1 == unrollcol) && (rowidx + 1 == unrollrow)) {
                    //     (0, 0, inchidx, outchidx + 1, 0, 0)
                    // } else if (colidx + 1 == unrollcol){
                    //     (rowidx + 1, 0, inchidx, outchidx, 0, 0)
                    // } else {
                    //     (rowidx, colidx + 1, inchidx, outchidx, 0, 0)
                    // }
                    if ((colidx + 1 == unrollcol) && (rowidx + 1 == unrollrow) && (outchidx + 1 == unrolloutch) && (inchsubidx + 1 == packinch)){
                        (0, 0, inchidx + 1, 0, 0, 0)
                    }else if ((colidx + 1 == unrollcol) && (rowidx + 1 == unrollrow) && (outchidx + 1 == unrolloutch)){
                        (0, 0, inchidx, 0, inchsubidx + 1, 0)
                    } else if ((colidx + 1 == unrollcol) && (rowidx + 1 == unrollrow)) {
                        (0, 0, inchidx, outchidx + 1, inchsubidx, 0)
                    } else if (colidx + 1 == unrollcol){
                        (rowidx + 1, 0, inchidx, outchidx, inchsubidx, 0)
                    } else {
                        (rowidx, colidx + 1, inchidx, outchidx, inchsubidx, 0)
                    }
                }
            let loadInput = loadInputExpr uidxs params idxs 
            let loadWeight = loadWeightExpr uidxs uidxs_old params idxs
            let executeFMA = executeFMAExpr uidxs params idxs
            
            loadInput (loadWeight (executeFMA (genExpr (index + 1) (UnrollIndexes(rowidxnew, colidxnew, inchidxnew, outchidxnew, inchsubidxnew, wcolidxnew)) uidxs)))
        }

    genExpr 0 unrollidxs unrollidxs

fun vqdmulhq(sum : tensor<i32, 1>, mult : tensor<i32, 1>) -> i32 {
    sum <- cast<i32>((cast<i64>(sum) * cast<i64>(mult)) >> 32)
    _end_
}

let unrolledStoreExpr params idxs ops = 
    let unrollidxs = UnrollIndexes(0, 0, 0, 0, 0, 0)
    let nameinput = params->nameinput
    let nameweight = params->nameweight
    let nameinputpattern = params->nameinputpattern
    let (unrollrow, unrollcol, unrollinch, unrolloutch) = getUnrolls params idxs
    let (_, unrollwrow, unrollwcol, _) = params->weight_shape
    let packinch = ll.item (idxs->inch) (params->packinchs)
    let packoutch = ll.item (idxs->outch) (params->packoutchs)
    let tileoutchslen = ll.len (params->tileoutchs)
    let tileinchslen = ll.len (params->tileinchs)
    let (_, outh, outw, outch) = params->output_shape

    let rec genExpr index uidxs = 
        let (rowidx, colidx, inchidx, outchidx, wrowidx, wcolidx) = (uidxs->outrow, uidxs->outcol, uidxs->inch, uidxs->outch, uidxs->weightrow, uidxs->weightcol)
        // if(index == unrollrow * unrollcol * unrollinch * unrolloutch){
        if(index == unrollrow * unrollcol * unrolloutch){
            let (nextop, opsnew) = getop ops
            let idxsnew = updateIndexes idxs Inch 0
            nextop params idxsnew opsnew
        } else{
            let (rowidxnew, colidxnew, inchidxnew, outchidxnew, wrowidxnew, wcolidxnew) =
                if ((colidx + 1 == unrollcol) && (rowidx + 1 == unrollrow)) {
                    (0, 0, 0, outchidx + 1, 0, 0)
                } else if (colidx + 1 == unrollcol){
                    (rowidx + 1, 0, 0, outchidx, 0, 0)
                } else {
                    (rowidx, colidx + 1, 0, outchidx, 0, 0)
                }
            if(params->isQuant){
                let mult = getVarName Mult uidxs params idxs
                let shift = getVarName Shift uidxs params idxs
                let sum = getVarName Sum uidxs params idxs
                let zero = params->namezeropoints
                let output = params->nameoutput
                let inputpattern = params->nameinputpattern
                let inputpatternidx = getVarName Inputpatternidx uidxs params idxs
                let inputidx = getVarName Inputidx uidxs params idxs
                if(rowidx == 0 && colidx == 0){
                    !{
                        let ${mult} = ${params->namemult}[(${params->iternameoutch} + ${packoutch * outchidx}:${params->iternameoutch} + ${packoutch * (outchidx + 1)}:1,)]
                        let ${shift} = ${params->nameshift}[(${params->iternameoutch} + ${packoutch * outchidx}:${params->iternameoutch} + ${packoutch * (outchidx + 1)}:1,)]
                        // let _ = vqdmulhq(${sum}, ${mult})
                        ${sum} <- cast<i32>((cast<i64>(${sum}) * cast<i64>(${mult}) >> tensor((1,), 31i32)))
                        ${sum} <- (${sum} + (tensor((1,), {1i32}) << (${shift} - tensor((1,), {1i32})))) >> ${shift}
                        ${sum} <- ${sum} + ${zero}
                        // ${output}[(${inputpattern}[(${inputpatternidx},)] + ${params->iternameoutch}:${inputpattern}[(${inputpatternidx},)] + ${params->iternameoutch} + ${packoutch}:1,)] <- cast<i8>(${sum})
                        let ${inputidx} = ${inputpattern}[(${inputpatternidx},)] 
                        // ${output}[(0, ${inputidx} / ${outw * outch}, (${inputidx} % ${outw * outch}) / ${outch}, ${params->iternameoutch} + ${outchidx * packoutch}:${params->iternameoutch} + ${outchidx * packoutch + packoutch}:1,)] <- cast<i8>(${sum})
                        ${output}[(${inputidx} + ${params->iternameoutch} + ${outchidx * packoutch}:${inputidx} + ${params->iternameoutch} + ${outchidx * packoutch + packoutch}:1,)] <- cast<i8>(${sum})
                        ${genExpr (index + 1) (UnrollIndexes(rowidxnew, colidxnew, inchidxnew, outchidxnew, wrowidxnew, wcolidxnew))}
                    }
                } else{
                    !{
                        // let _ = vqdmulhq(${sum}, ${mult})
                        ${sum} <- cast<i32>((cast<i64>(${sum}) * cast<i64>(${mult}) >> tensor((1,), 31i32)))
                        ${sum} <- (${sum} + (tensor((1,), {1i32}) << (${shift} - tensor((1,), {1i32})))) >> ${shift}
                        ${sum} <- ${sum} + ${zero}
                        // ${output}[(${inputpattern}[(${inputpatternidx},)] + ${params->iternameoutch}:${inputpattern}[(${inputpatternidx},)] + ${params->iternameoutch} + ${packoutch}:1,)] <- cast<i8>(${sum})
                        let ${inputidx} = ${inputpattern}[(${inputpatternidx},)] 
                        // ${output}[(0, ${inputidx} / ${outw * outch}, (${inputidx} % ${outw * outch}) / ${outch}, ${params->iternameoutch} + ${outchidx * packoutch}:${params->iternameoutch} + ${outchidx * packoutch + packoutch}:1,)] <- cast<i8>(${sum})
                        ${output}[(${inputidx} + ${params->iternameoutch} + ${outchidx * packoutch}:${inputidx} + ${params->iternameoutch} + ${outchidx * packoutch + packoutch}:1,)] <- cast<i8>(${sum})
                        ${genExpr (index + 1) (UnrollIndexes(rowidxnew, colidxnew, inchidxnew, outchidxnew, wrowidxnew, wcolidxnew))}
                    }
                }
            } else{
                let sum = getVarName Sum uidxs params idxs
                let output = params->nameoutput
                let inputpattern = params->nameinputpattern
                let inputpatternidx = getVarName Inputpatternidx uidxs params idxs
                let inputidx = getVarName Inputidx uidxs params idxs
                let prefusionExpr nextop = 
                    if(outchidx == 0){
                        !{
                            let ${inputidx} = ${inputpattern}[(${inputpatternidx},)] + ${params->iternameoutch}
                            ${nextop}
                        }
                    } else{
                        nextop
                    }
                let postfusionExpr = !{
                    ${output}[(${inputidx} + ${outchidx * packoutch}:${inputidx} + ${outchidx * packoutch + packoutch}:1,)] <- ${sum}
                    ${genExpr (index + 1) (UnrollIndexes(rowidxnew, colidxnew, inchidxnew, outchidxnew, wrowidxnew, wcolidxnew))}
                }
                let microopsimpls = params->postmicroopsimpls
                let vectordtype =
                    match (params->packedweight) with
                        | ut.TensorF32 x -> rtType(f32)
                        | ut.TensorF16 x -> rtType(f16)
                        | ut.TensorI8 x -> rtType(i32)
                let fusionExpr = fsn.genMicroOpsExpr microopsimpls sum sum ([!{${inputidx} + ${outchidx * packoutch}}]) packoutch vectordtype
                prefusionExpr (fusionExpr postfusionExpr)
            }
        }

    genExpr 0 unrollidxs


_end_