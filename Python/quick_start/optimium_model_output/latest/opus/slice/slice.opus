module slice.utils as u
module core.List.List as ll
module common.utils as commonutils
module common.params as params


template</attr_params: params.Attributes, optim_params: params.Optimization, layer_params: params.Layerargs,
    input_data: ll.List<ll.List<ut.UnionTensor>>, input_dtypes: ll.List<ll.List<rtType>>, input_shapes: ll.List<ll.List<i32>>, input_scales: ll.List<ll.List<ut.UnionTensor>>, input_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    output_dtypes: ll.List<ll.List<rtType>>, output_shapes: ll.List<ll.List<i32>>, output_scales: ll.List<ll.List<ut.UnionTensor>>, output_zero_points: ll.List<ll.List<ut.UnionTensor>>,
    input_edges: ll.List<ll.List<tuple<i32, i32>>>, output_edges: ll.List<ll.List<tuple<i32, i32>>>, ismainops: ll.List<boolean>,
    input_t: rtType, input_rt_list : ll.List<rtType>,  output_t: rtType, output_rt_list : ll.List<rtType>/>
attr[Extern : attr_params->name, Optimization : { VectorSize : 512 }]
fun slice(inputs: input_t, mut &outputs: output_t) -> i32{
    ${
        let layerindex = (
            let mut index = 0
            for(i from 0 to (ll.len layer_params)){
                match (ll.item i layer_params) with 
                    | params.Slice x   -> if((ll.item i ismainops)){index <- i} else{_end_}
                    | _                 -> _end_
            }
            index
        )

        let layerparams = 
            match (ll.item layerindex layer_params) with 
                | params.Slice x -> x

        let pack = ll.item 0 (optim_params->pack)
        let unroll = ll.item 0 (optim_params->unroll)
        let input1_dtype = ll.item 0 (ll.item layerindex input_dtypes)
        let input1_shape = ll.item 0 (ll.item layerindex input_shapes)
        let input1_scales = ll.item 0 (ll.item layerindex input_scales)
        let input1_zero_points = ll.item 0 (ll.item layerindex input_zero_points)
        let output_dtype = ll.item 0 (ll.item layerindex output_dtypes)
        let output_shape = ll.item 0 (ll.item layerindex output_shapes)
        let output_scales = ll.item 0 (ll.item layerindex output_scales)
        let output_zero_points = ll.item 0 (ll.item layerindex output_zero_points)

        let slice_dim = layerparams->slice_dim
        let slice_start = layerparams->slice_start
        let slice_end = layerparams->slice_end
        let slice_step = layerparams->slice_step
        let squeeze_indices = layerparams->squeeze_indices
        let framework = layerparams->framework

        let templateparams = u.TemplateParameters(input_t, input1_dtype, input1_shape,
                                output_t, output_dtype, output_shape, framework,
                                slice_dim, slice_start, slice_end, slice_step, squeeze_indices)
        let params = u.initCodeGen templateparams
        print(params->slice_start)
        print(params->slice_end)
        print(params->slice_step)
        !{
            let mut outp = &outputs[|0|]
            let batchin = inputs[|0|]
            outp <- batchin[${ll.toRtTuple <| params->input_index}]
            0
        }
    }
}