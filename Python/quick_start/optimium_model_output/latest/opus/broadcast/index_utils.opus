module core.List.List as ll
module common.utils as commonutils

let get_maxmin_len_binary input1_shape input2_shape = if (ll.len input1_shape > ll.len input2_shape){
        (ll.len input1_shape, ll.len input2_shape, "input1")
    } else{
        (ll.len input2_shape, ll.len input1_shape, "input2")
    }

let get_input_dim input_key maxinput maxlen minlen input_shape index = 
    if (maxinput == input_key){
        ll.item <| index <| input_shape
    } else{
        if(index < (maxlen - minlen)){
            1
        } else{
            ll.item <| (index - maxlen + minlen) <| input_shape
        }
    }

let rec check_broadcast_dim maxlen minlen get_input1_dim get_input2_dim index =
    if (index == maxlen){
        ([], [])
    } else if(index < (maxlen - minlen)){
        let (next_broadcast_dim, next_nonbraodcast_dim) = check_broadcast_dim <| maxlen <| minlen <| get_input1_dim <| get_input2_dim <| (index + 1)
        (index ; next_broadcast_dim, next_nonbraodcast_dim)
    } else{
        let (next_broadcast_dim, next_nonbraodcast_dim) = check_broadcast_dim <| maxlen <| minlen <| get_input1_dim <| get_input2_dim <| (index + 1)
        if ((get_input1_dim <| index) != (get_input2_dim <| index)){
            (index ; next_broadcast_dim, next_nonbraodcast_dim)
        } else{
            (next_broadcast_dim, index ; next_nonbraodcast_dim)
        }
    }

let rec getting_consectuvie_dim nonbraodcast_dim index post_dim=
    if(index < 0){
        (-1, 0)
    } else{
        let cur_dim = ll.item <| index <| nonbraodcast_dim
        if (cur_dim != (post_dim -1i)){
            // broadcast dim cut consecutiveness
            (index+1i, post_dim)
        } else{
            // stil consecutive
            getting_consectuvie_dim <| nonbraodcast_dim <| (index-1i) <| cur_dim
        }
    }

let get_consecutive_flattend_shape index_offset input_shape last_consecutive_dim =
    let rec impl index =
        if(index < index_offset){
            impl <| (index+1i)
        } else if (index < last_consecutive_dim){
            let next_result = impl <| (index+1i)
            (ll.item <| (index - index_offset) <| input_shape ) ; next_result
        } else{
            let drop_last = ll.take <| ((ll.len <| input_shape) - index_offset) <| input_shape
            let drop_first = ll.drop <| (last_consecutive_dim  - index_offset) <| drop_last
            [commonutils.factorial <| drop_first ]
        }
    impl <| 0i

_end_